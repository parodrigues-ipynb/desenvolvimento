# Cuidado de idosos

Este documento tem por objetivo registrar as etapas de desenvolvimento das diversas partes (rob√¥, sensores, alarmes...) que integram o projeto de cuidado de idosos sendo desenvolvido por um grupo de alunos na disciplina **Desenvolvimento de Aplica√ß√µes para Automa√ß√£o** ministrada pelo professor Alexandre St√ºrmer Wolf na Univates.

O grupo √© integrado por:
* Anderson da Silva Quadros;
* Jonathan Tabaldi Bassani;
* Marcelo Teichenbach;
* Pedro Augusto Rodrigues;
* Samuel Dornelles

Cada membro do grupo envolveu-se em diferentes partes do projeto.

![B1-M1](https://media1.giphy.com/media/v1.Y2lkPTZjMDliOTUyYWtraTV2dTdxNW42OGphMnJvZnplNmpqM2wzbmhwb2UxcnhpdDFkbCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/3o7abB06u9bNzA8lu8/giphy.gif)

## B1-M1 - Rob√¥ de monitoramento
Membros envolvidos:
* Anderson da Silva Quadros;
* Pedro Augusto Rodrigues

O B1-M1 √© um rob√¥ de monitoramento.

Talvez a primeira pergunta que surja seja "e qual a rela√ß√£o dele com o cuidado de idosos?".

Bem, digamos que o sensor do banheiro dispare um alarme de que talvez ocorreu um acidente, pois algu√©m entrou no c√¥modo mas n√£o houve registro de sa√≠da depois do intervalo de tempo limite do sensor.

O B1-M1 pode ser √∫til para se deslocar at√© o banheiro e abrir uma stream de v√≠deo e chamada por voz para checar o que pode ter ocorrido, permitindo a alguma terceira pessoa checar se est√° tudo bem com a pessoa idosa.

Enfim, a maior motiva√ß√£o do projeto √© um grande interesse em rob√≥tica.

O grupo pretende alcan√ßar os seguintes objetivos para o rob√¥ B1-M1:
1. mover-se seguindo uma rotina pr√©-determinada em um ambiente residencial plano e permitir controle remoto;
2. registrar valores obtidos pelo sensoriamento ultrass√¥nico e visual (fotografias) e permitir o stream (v√≠deo) durante o acesso remoto;
3. comunicar-se com o Gemini atrav√©s da API fornecida pelo Google a fim de obter instru√ß√µes para movimento aut√¥nomo.

Tanto os alunos Anderson quanto Pedro nunca fizeram antes um projeto de rob√≥tica. Portanto, os objetivos listados acima s√£o desafiadores para o grupo.

Para fins did√°ticos e de cria√ß√£o de um memorial de aprendizado, o grupo decidiu documentar o progresso feito na constru√ß√£o do B1-M1.

A documenta√ß√£o √© apresentada abaixo. Cada inser√ß√£o conta com notas pessoais de aprendizado do grupo. Algumas linhas podem parecer excessivamente detalhadas - muita vezes com informa√ß√µes que podem parecer √≥bvias a algu√©m mais experiente - mas √© importante lembrar que elas foram escritas mais como um caderno de aula do que como uma documenta√ß√£o profissional.

---

### Rela√ß√£o de componentes utilizados

Nesta se√ß√£o est√£o listados os componentes utilizados.

Houve uma infinidade de terminais, parafusos, porcas, brocas, fixadores, cabos, espa√ßadores... al√©m da estrutura MDF que n√£o foi listada, j√° que a estutura atual do B1-M1 √© apenas um prot√≥tipo.

<details>
  <summary>üìù Rela√ß√£o de componentes [clique para expandir]</summary>

  1x [Placa de desenvolvimento ESP32S-NodeMCU 38 pinos](https://www.usinainfo.com.br/esp32/esp32s-nodemcu-iot-com-wifi-e-bluetooth-38-pinos-com-usb-c-e-cp2102-8796.html)
  
  1x [Placa de desenvolvimento ESP32-CAM-CH340 com c√¢mera OV2640](https://www.usinainfo.com.br/esp32/esp32-cam-ch340-ov2640-iot-com-programador-integrado-8758.html)
  
  3x [Bateria de l√≠tio 18650 3.7V recarreg√°vel button-top](https://www.usinainfo.com.br/baterias/bateria-18650-litio-recarregavel-37v-3800mah-button-top-kit-com-2-unidades-8170.html)
  
  1x [Suporte para 3 baterias 18650](https://www.usinainfo.com.br/suporte-para-pilhas/suporte-para-3-baterias-18650-smt-9059.html)
  
  1x [Placa de prote√ß√£o para bateria (BMS - Battery Management System) 18650-3S-20A](https://www.usinainfo.com.br/controladores-de-carga/placa-de-protecao-para-bateria-18650-3s-20a-12v-hx-3s-fl20-7070.html)
  
  1x [Regulador de tens√£o XL4015 DC/DC step down 8-36V ‚Üí 1,25-32V 0,2-3A](https://www.usinainfo.com.br/regulador-de-tensao/regulador-de-tensao-e-corrente-ajustavel-xl4015-dc-step-down-saida-125-a-32vdc-02-a-3a-5880.html)
  
  1x [Regulador de tens√£o LM2596DC DC/DC step down 3,2-40V ‚Üí 1,5-35V 1,2A](https://www.usinainfo.com.br/regulador-de-tensao/regulador-de-tensao-ajustavel-lm2596-dc-step-down-saida-15v-a-35vdc-12a-2552.html)
  
  1X [Sensor de dist√¢ncia ultrass√¥nico HC-SR04](https://www.usinainfo.com.br/sensor-ultrassonico/sensor-ultrassonico-de-distancia-hc-sr04-2295.html)
  
  1x [Driver motor DC ponte H TB6612FNG](https://www.usinainfo.com.br/driver-para-motor/driver-tb6612fng-duplo-ponte-h-de-motor-dc-ou-passo-4697.html)
  
  2x [Motor DC 3~6V 200RPM com caixa de redu√ß√£o 48:1](https://www.usinainfo.com.br/motor-dc/motor-dc-3-6v-200rpm-com-caixa-de-reducao-e-eixo-duplo-481--3161.html)
  
  2x [Sensor de velocidade encoder LM393](https://www.usinainfo.com.br/sensor-de-velocidade/sensor-de-velocidade-para-arduino-sensor-de-contagem-chave-optica-para-encoder-5mm-4486.html)
  
</details>

---

### Memorial de c√°lculo de dimensionamento

Nesta se√ß√£o est√£o  registrados a metodologia e os c√°lculos utilizados para dimensionamento dos componentes do B1-M1.

<details>
  <summary>üìù Memorial [clique para expandir]</summary>
  
  Como a alimenta√ß√£o el√©trica √© a espinha dorsal de todo projeto de eletr√¥nica embarcada, o primeiro passo dado pelo grupo foi estimar o consumo de corrente dos componentes utilizados para atingir os objetivos.
  
  #### Consumo de corrente
  
  | Componente                        | Quantidade  | Consumo total | 
  |-----------------------------------|:-----------:|:-------------:|
  | ESP32S-NodeMCU                    | 1           | ~250mA[^1]    |
  | ESP32-CAM                         | 1           | ~250mA[^2]    |
  | Sensor ultrass√¥nico HC-SR04       | 1           | ~15mA         |
  | Driver motor TB6612FNG            | 1           | ~1,5mA        |
  | Motor DC 3-6V 200RPM              | 2           | ~400mA[^3]    |
  | Sensor de velocidade LM393        | 2           | ~20mA         |
  | **Total**                         | **8**       | **~936,5mA**  |
  
  Para fins de c√°lculo, arredondar-se-√° o consumo total para 1A (1000mA).
  
  #### Autonomia
  
  ![18650](https://i.imgur.com/sR7YUmA.jpeg)
  
  As baterias de l√≠tio 18650 t√™m gravado nos seus inv√≥lucros a capacidade de carga el√©trica de **3800mAh**. Por√©m, [√© interessante notar que o vendedor fez testes e alegou a capacidade de apenas 1500mAh](https://www.usinainfo.com.br/baterias/bateria-18650-litio-recarregavel-37v-3800mah-flat-top-8760.html). Portanto, para fins de c√°lculo neste trabalho, adotar-se-√° o valor de **1500mAh**.
  
  Fazendo um c√°lculo simples de autonomia,
  
  $Autonomia = \frac{Capacidade \ de \ carga \ el√©trica}{Consumo \ de \ corrente \ el√©trica} = \frac{1500mAh}{1000mA} ‚âà 1,5h$
  
  Logo, o grupo espera que o B1-M1 tenha uma autonomia de aproximadamente **1 hora e 30 minutos** funcionando com as premissas de consumo feitas na tabela **Consumo de corrente**.
  
  #### Se√ß√£o dos cabos utilizados
  
  Como cabos de bitola 1mm¬≤ suportam correntes cont√≠nuas de at√© 10A, adotou-se o seu uso nas conex√µes do pack de baterias 18650 com a BMS e da BMS com os reguladores de tens√£o.
  
  Nas demais conex√µes utilizou-se cabos de 0,75mm¬≤, que suportam correntes cont√≠nuas de at√© 8A.
</details>

---

### Esquem√°tico

![Esquem√°tico](https://i.imgur.com/hKs6kS9.jpeg)

Uma imagem em alta resolu√ß√£o do esquem√°tico pode ser vista [aqui](https://i.imgur.com/tPJJAKS.png)

Algumas notas sobre decis√µes feitas foram colocadas abaixo.

<details>
  <summary>üíΩ Capacitores de desacoplamento de 100nF nos terminais dos motores A e B [clique para expandir]</summary>

  ![Motores escovados](https://i.imgur.com/eeTXd8O.jpeg)
  
  Motores produzem ru√≠do.
  
  No contexto do B1-M1, "ru√≠do" √© entendido como as ondas eletromagn√©ticas emitidas por um dispositivo durante seu funcionamento afetarem o funcionamento de outros dispositivos eletr√¥nicos.
  
  Ru√≠do √© um problema dif√≠cil de resolver, pois fisicamente eles s√£o uma forma de energia eletromagn√©tica - que tamb√©m √© a descri√ß√£o para sinais el√©tricos. Assim, como distinguir sinais de ru√≠dos? A energia eletromagn√©tica que √© essencial para o funcionamento de um sistema pode ser a causa de ru√≠do indesejado para outro.
  
  Nos motores DC utilizados neste projeto, uma das fontes de ru√≠do poss√≠veis √© devido √† comuta√ß√£o entre as escovas de carbono e o anel coletor laminado (o comutador) do induzido.
  
  [GIF mostrando os arcos voltaicos](https://i.imgur.com/fCO2iG0.gif)
  
  Quando as escovas e as l√¢minas do anel coletor comutam ocorrem arcos voltaicos (*comutar = ligar ou desligar, interromper e religar uma liga√ß√£o el√©trica*). Esses arcos ocorrem pois uma vez energizadas as bobinas do enrolamento do induzido se comportam como indutores.
  
  A equa√ß√£o da tens√£o para indutores √© $v = L \frac{di}{dt}$
  
  Ou seja, a tens√£o √© proporcional √† taxa de varia√ß√£o da corrente.
  
  Quando a comuta√ß√£o ocorre, a taxa de varia√ß√£o da corrente √© abrupta e intensa (indo de 100% para 0% em um intervalo de tempo muito pequeno). Essa grande taxa de varia√ß√£o provoca um pico de tens√£o nas bobinas e, por consequ√™ncia, os arcos voltaicos entre as escovas e as l√¢minas do anel coletor. Os picos de tens√£o no funcionamento de um motor DC podem ser vistos na imagem abaixo.
  
  ![Ru√≠do](https://i.imgur.com/xDD7Uay.jpeg)
  
  O objetivo dos capacitores pr√≥ximos aos terminais do motor √© de suprimir um pouco esses picos de tens√£o gerados pela comuta√ß√£o das escovas e das l√¢minas do coletor.

  √â importante notar que foram utilizados capacitores cer√¢micos pois o sentido da corrente pode inverter conforme o sentido de giro dos motores.
  
</details>

<details>
  <summary>üíΩ Capacitor de 1000¬µF entre os terminais VM e GND do driver motor TB6612FNG [clique para expandir]</summary>

  Quando os motores A e B est√£o ligados, eles podem demandar picos de corrente em fun√ß√£o de partidas ou frenagens. Esses picos fazem a tens√£o de alimenta√ß√£o oscilar.

  ![Corrente inrush](https://i.imgur.com/AXEOBzh.jpeg)

  Os picos de corrente s√£o chamados de corrente *inrush*.

  Quando aplicamos uma tens√£o el√©trica $V$ sobre os terminais do motor DC surge uma corrente el√©trica $I$ nos enrolamentos do induzido. Essa corrente $I$, na presen√ßa do campo magn√©tico $\overrightarrow{B}$ criado pelos √≠m√£s internos do motor DC, gera uma for√ßa $F$ sobre as espiras das bobinas do induzido - fen√¥meno este que est√° de acordo com o princ√≠pio da Lei de Lorentz (inclusive, [fiz um trabalho sobre a Lei de Lorentz](https://docs.google.com/presentation/d/1fynI4v6RXC3prIWHDpS9ZRpDoe6CXCrVUi7HYExRhsw/edit?usp=sharing)! Nesse trabalho explico bem a fundo esse conceito f√≠sico).

  Por√©m, embora a corrente el√©trica apare√ßa rapidamente nas bobinas do induzido em fun√ß√£o do campo el√©trico $\overrightarrow{E}$ que estamos estabelecendo com a tens√£o $V$ aplicada aos terminais do motor (inclusive, aconselho assistir a [esse √≥timo v√≠deo do canal AlphaPhoenix sobre a velocidade da eletricidade](https://www.youtube.com/watch?v=2Vrhk5OjBP8)), o motor n√£o come√ßa a girar instantaneamente.
  
  Ou seja, haver√° um breve momento em que a corrente $I$ atravessar√° as bobinas do induzido com o induzido praticamente parado, e nesse breve momento √© como se o induzido se comportasse como um curto-circuito, pois suas bobinas t√™m uma resist√™ncia $R$ muito baixa e atuam praticamente como se fossem indutores.

  Indutores em circuitos DC atuam como se fossem curto-circuito pois sua imped√¢ncia $X_L$ √© dada por $X_L = 2œÄfL$, e $f = 0Hz$ em um circuito DC (logo, $X_L = 0$). A √∫nica propriedade f√≠sica das bobinas que se op√µe √† passagem da corrente $I$ √© a sua resist√™ncia $R$, que √© muito baixa.

  Pela Lei de Ohm, $I = \frac{V}{R}$. Portanto, se o denominador $R$ for muito pequeno, $I$ ser√° muito grande. O qu√£o grande? Bem, at√© o valor de pico da corrente *inrush*.

  Embora tenhamos explicado o motivo da corrente *inrush* surgir, n√£o explicamos ainda o que faz ela "diminuir". Sabemos que deve ter algo a ver com a velocidade de giro do induzido, pois a curva da corrente *inrush* se comporta da seguinte maneira:
  * cresce conforme o induzido sai da posi√ß√£o parado e come√ßa a adquirir velocidade;
  * atinge um pico quando o induzido atinge uma determinada velocidade;
  * decresce quando o induzido ultrapassa essa determinada velocidade;
  * estabiliza quando o induzido atinge sua velocidade nominal.

  O surgimento da corrente *inrush* estava relacionado √† baixa resist√™ncia $R$ das bobinas. Entretanto, j√° que a resist√™ncia $R$ n√£o muda conforme o induzido gira mais r√°pida ou mais lentamente, a resist√™ncia $R$ n√£o deve ser a causa da estabiliza√ß√£o da corrente $I$. Por√©m, √© claro que o motivo da estabiliza√ß√£o da corrente tem rela√ß√£o com o giro do induzido.

  E √© justamente o giro do induzido a causa da estabaliza√ß√£o. Assim que o motor come√ßa a girar ocorre um fen√¥meno muito peculiar: o motor estabelece o que conhecemos por for√ßa contra-eletro motriz (ou $FCEM$) proporcional √† sua velocidade - o que est√° de acordo com o princ√≠pio da Indu√ß√£o Eletromagn√©tica de Faraday, que nos diz que a for√ßa eletromotriz $\epsilon$ gerada √© proporcional √† vari√ß√£o de fluxo magn√©tico $ŒîŒ¶$ e inversamente proporcional √† varia√ß√£o do tempo $Œît$, ou $\epsilon = - \frac{ŒîŒ¶}{Œît}$.

  Em outras palavras:
  * as bobinas do induzido s√£o condutores em movimento dentro do campo magn√©tico $\overrightarrow{B}$ dos √≠m√£s do motor;
  * o campo magn√©tico $overrightarrow{B}$ tem linhas de fluxo magn√©tico $Œ¶$ que atravessam os condutores enquanto o induzido gira;
  * como os condutores est√£o em movimento, a quantidade de linhas de fluxo magn√©tico $Œ¶$ est√° variando - logo, na verdade √© um $ŒîŒ¶$ alto com $Œît$ baixo;
  * $\epsilon = - \frac{ŒîŒ¶}{Œît}$. O sinal negativo √© uma consequ√™ncia da Lei da Conserva√ß√£o de Energia (a tens√£o induzida se op√µe √† tens√£o original que a induziu);
  * $\epsilon = FCEM$.

  Certo! E o que tudo isso tem a ver com o capacitor de 1000¬µF entre os terminais VM e GND do TB6612FNG?

  Bem, embora "microFarad" (¬µF) possa soar como algo pequeno, esse valor de capacit√¢ncia certamente n√£o √© pequeno. De fato, 1000¬µF √© o suficiente para fornecer uma corrente el√©trica "extra" quase que imediatamente quando o motor DC d√° partida ou freia. A proximidade do capacitor dos terminais VM e GND torna a resposta ainda mais r√°pida.

  Se o capacitor n√£o estivesse presente, haveria uma maior tend√™ncia de ocorrerem quedas de tens√£o na alimenta√ß√£o dos motores nos momentos de corrente *inrush*.
  
</details>

---

### Desenvolvimento do c√≥digo

O c√≥digo inicial e as vers√µes com melhorias e altera√ß√µes feitas pelo grupo est√£o listadas abaixo. A ordem √© cronol√≥gica e conta sempre com o c√≥digo integral, um v√≠deo e uma breve discuss√£o sobre conceitos utilizados.

---

#### 13/10/2025

üíæ [C√≥digo vers√£o 1](https://gist.github.com/parodrigues-ipynb/be9dc512e9a064356e3e1a73c458425b)

üé• [V√≠deo B1-M1 rodando com a vers√£o 1](https://imgur.com/a/WtTMg6K)

<details>
  <summary>üìù Coment√°rios sobre o c√≥digo vers√£o 1 [clique para expandir]</summary>
  
  ```ino
  // Linha 2
  #define PWMA 4
  ```
  `#define` √© uma diretiva de pr√©-processador da linguagem C/C++ que cria uma constante simb√≥lica. O compilador substitui todas as ocorr√™ncias do nome pelo valor definido antes de compilar. Por exemplo, `#define PWMA 4` substitui `PWMA` por `4` no momento anterior √† compila√ß√£o. O uso de `#define` √© √∫til para mapear pinos e definir valores fixos/limites (dist√¢ncias, velocidades...) que permanecer√£o constantes ao longo do c√≥digo, tornando as informa√ß√µes mais claras e f√°ceis de alterar.
  
  ```ino
  // Linha 10
  uint8_t pwmA = 94;
  ```
  A vari√°vel `pwmA` ir√° armazenar os valor de duty cycle para o sinal PWM enviado ao motor A.
  
  PWM significa *Pulse Width Modulation*, ou *Modula√ß√£o de Largura de Pulso*. *Duty cycle*, ou *ciclo de trabalho*, representa a raz√£o entre a **largura de pulso** ($t_{ON}$), que √© o tempo em que o sinal permanece em n√≠vel HIGH, e o **per√≠odo total do sinal** ($T$), conforme a express√£o:
  
  ![Duty cycle](https://i.imgur.com/GDkGRCn.png)
  
  Por exemplo, se o per√≠odo $T$ fosse 100ms, um *duty cycle* de 25% teria uma largura de pulso $t_{ON}$ de 25ms.
  
  ![Sinal PWM](https://i.imgur.com/OkiNbwV.jpeg)
  
  A imagem acima mostra diferentes sinais de tens√£o PWM. As linhas verticais laranjas s√£o as marca√ß√µes de tempo. Portanto, todos os sinais compartilham o mesmo per√≠odo $T$.
  
  Na imagem os sinais de tens√£o PWM t√™m *duty cycles* distintos: 0%, 25%, 50%, 75% e 100%.
  
  Quando o *duty cycle* √© 0%, a tens√£o de sa√≠da √© 0V. Quando o *duty cycle* √© de 100%, a tens√£o de sa√≠da √© 5V.
  
  √â interessante notar que com *duty cycle* de 50% resulta numa tens√£o de sa√≠da m√©dia de 2,5V. 25% resulta em uma tens√£o m√©dia de 1,25V. Essas tens√µes m√©dias s√£o indicadas pelas linhas laranjas grossas horizontais apontadas pelas setas verdes na caixa de texto *Average Output Voltage*, ou *Tens√£o M√©dia de Sa√≠da*.
  
  √â uma pr√°tica comum utilizar vari√°veis num√©ricas para representar o *duty cycle* em c√≥digo. Por exemplo, seria teoricamente poss√≠vel criar uma vari√°vel `int pwmA = 0` para representar um *duty cycle* de 0%. Caso fosse desej√°vel alterar o duty cycle para 1%, poderia-se simplesmente alterar o valor da vari√°vel para `pwma = 1`, ou 2% ‚Üí `pwma = 2`, e assim por diante.
  
  O tipo de vari√°vel `int` √© usado para armazenar n√∫meros inteiros (-2, -1, 0, 1, 2, 3...). Na ESP32, o `int` ocupa **4 bytes** (32 bits) - o que faz sentido, j√° que o microcontrolador √© baseado em arquitetura 32 bits. Os valores poss√≠veis para vari√°veis do tipo `int` v√£o de -2,147,483,648 at√© 2,147,483,647. √â poss√≠vel utlizar `unsigned int` para trabalhar-se com o intervalo de 0 at√© 4,294,967,295 (aproximadamente 4 bilh√µes).
  
  Portanto, no caso da linha 10, poder√≠amos teoricamente utilizar a vari√°vel `unsigned int pwmA` para mapear o *duty cycle*. Se desej√°ssemos utilizar todo o potencial de armazenamento do tipo `unsigned int`, como queremos mapear valores de 0% at√© 100% num intervalo de 0 at√© 4,294,967,295, far√≠amos $\frac{100\\% - 0\\%}{4,294,967,295 - 0} ‚âà 0,00000002328\\%$.
  
  Assim, ter√≠amos a seguinte resolu√ß√£o:
  * `pwmA = 0             // ‚Üí 0%`
  * `pwmA = 1             // ‚Üí ‚âà 0,00000002328%`
  * `pwmA = 2             // ‚Üí ‚âà 0,00000004657%`
  * ...
  * `pwmA = 4294967294    // ‚Üí ‚âà 99,9999999767%`
  * `pwmA = 4294967295    // ‚Üí 100%`
  
  Agora imaginemos programadores tendo de cotidianamente utilizar essa resolu√ß√£o em seus c√≥digos. Seria um pesadelo ter de lembrar o valor 4294967295, e muito dif√≠cil lembrar os valores que mapeam para aproximadamente 25%, 50%, 75%...
    
  Portanto, no caso de sinais PWM, √© comum utilizar-se tipos de vari√°veis de apenas **1 byte** (8 bits), que na base bin√°ria ($2^n$) correspondem a 256 valores poss√≠veis ($2^8 = 256$). Como $\frac{100\\%-0\\%}{255-0} ‚âà 0,39\\%$, ter√≠amos a seguinte resolu√ß√£o:
  * `pwmA = 0             // ‚Üí 0%`
  * `pwmA = 1             // ‚Üí ‚âà 0,39%`
  * `pwmA = 2             // ‚Üí ‚âà 0,78%`
  * ...
  * `pwmA = 254           // ‚Üí ‚âà 99,61%`
  * `pwmA = 255           // ‚Üí 100%`
  
  No caso da vari√°vel `pwmA = 94`, temos um *duty cycle* de aproximadamente 37%.
  
  Fica evidente que 1 byte j√° traz uma resolu√ß√£o adequada para se programar e ainda possibilita inferir algumas porcentagens intuitivamente:
  * como 100% ‚Üí 255,
  * ent√£o 50% deve ser algo em torno de 127,
  * 25% deve ser algo em torno de 64...
  e assim por diante.
  
  `uint8_t` significa *unsigned integer of length 8 bits*, ou *n√∫mero inteiro sem sinal de comprimento de 8 bits*. √â muito comum encontrar softwares e hardwares que utilizam sinais PWM mapeados por vari√°veis de 8 bits. Entretanto, √© sempre bom ficar atento √†s conven√ß√µes adotadas em cada projeto pois pode haver casos em que uma maior resolu√ß√£o √© necess√°ria a fim de alcan√ßar maior precis√£o.
  
  ```ino
  // Linha 16
  #define TIMEOUT_US 20000 // [¬µs]
  ```
  O sensor de dist√¢ncia ultrass√¥nico HC_SR04 tem dois componentes principais: um emissor e um receptor de pulsos ultrass√¥nicos.
  
  ![HC_SR04](https://i.imgur.com/9TA6kXy.jpeg)
  
  Chamamos de "som" a propaga√ß√£o de uma onda mec√¢nica atrav√©s de um meio - comumente nossa atmosfera, ou o nosso "ar".
  
  "Ultrass√¥nico" signica um som fora do espectro de audi√ß√£o humana, que costuma ir de aproximadamente 20Hz at√© 20kHz. Como os pulsos que o HC_SR04 emite t√™m frequ√™ncia de 40kHz, ent√£o eles s√£o ultrass√¥nicos.
  
  O funcionamento do sensor √© simples: ele emite um pulso ultrass√¥nico, inicia um cron√¥metro interno e aguarda o receptor identificar o eco do pulso original transmitido, momento no qual o cron√¥metro √© encerrado.
  
  O som se propaga na atmosfera terrestre a 20¬∞C com uma velocidade de aproximadamente 343m/s, ou 0,0343cm/¬µs.
  
  O [datasheet do HC_SR04](https://cdn.sparkfun.com/datasheets/Sensors/Proximity/HCSR04.pdf) especifica que o sensor √© capaz de realizar medi√ß√µes de 2cm at√© 4m.
  
  A defini√ß√£o de velocidade $v$ √© a raz√£o da dist√¢ncia $d$ sobre o tempo $t$, ou
  
  ![Velocidade](https://i.imgur.com/3BgQRWY.png)
  
  Como o pulso ultrass√¥nico deve ir, colidir com um obst√°culo e voltar, o tempo medido pelo sensor corresponde √† ida e volta do pulso ultrass√¥nico. Portanto, para calcular a dist√¢ncia, devemos dividir o tempo por 2:
  
  ![Dist√¢ncia](https://i.imgur.com/dC75AcF.png)
  
  Substituindo os valores de limite de dist√¢ncia do HC_SR04 e multiplicando as dist√¢ncias por 2 para compensar o ajuste feito pelo sensor, temos:
  
  ![Tempos](https://i.imgur.com/0LC2vbj.png)
  
  O [datasheet do HC_SR04](https://cdn.sparkfun.com/datasheets/Sensors/Proximity/HCSR04.pdf) estabelece a seguinte pr√°tica para a emiss√£o do pulso ultrass√¥nico:
  * o pino TRIG deve ser mantido em LOW por 2¬µs a fim de garantir estabilidade, evitando que o pulso no pino TRIG que vir√° a seguir seja confundido com o sinal residual de alguma medi√ß√£o anterior. Estamos "resetando" o HC_SR04 com esse pulso LOW de 2¬µs;
  * o pino TRIG deve ser mantido em HIGH por 10¬µs para identificar o comando de emiss√£o do pulso ultrass√¥nico;
  * o pulso ultrass√¥nico √© emitido. S√£o 8 pulsos numa frequ√™ncia de 40kHz. Isso faz cada pulso ter 25¬µs de dura√ß√£o e a emiss√£o total demorar 200¬µs;
  * ap√≥s a emiss√£o do pulso ultrass√¥nico, o pino ECHO entra em n√≠vel HIGH e permanece assim at√© que o oitavo pulso seja processado pelo receptor na volta. Quando o oitavo pulso for detectado, o pino ECHO retorna ao n√≠vel LOW;
  * se o tempo TIMEOUT_US for excedido, o pino ECHO retorna a LOW. Portanto, `TIMEOUT_US` √© o limite de tempo em microssegundos que o sensor ultrass√¥nico deve aguardar sem que o receptor identifique o eco do pulso ultrassonoro original.
  
  Toda essa rotina consta nas linhas 36 at√© 44 do c√≥digo.
  
  ```ino
  // Linhas 36 at√© 44
  digitalWrite(TRIG, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG, LOW);
  
  long duracao = pulseIn(ECHO, HIGH, TIMEOUT_US);
  float distancia = duracao * 0.0343 / 2; // [cm]
  ```
  
  O diagrama de tempo abaixo apresenta o funcionamento das partes do HC_SR04 visualmente. 
  
   ```
      ________________________________________________________________________________________________________
     |                                                                                                        |
     | Pino            ‚îå‚îê                                     TIMEOUT_US = 20000¬µs ‚îå‚îê                         |
     | TRIG            ||                                               ‚Üì          ||                         |
     | HC_SR04      ---‚îò‚îî-----------------------------------------(...)---(...)----‚îò‚îî-------------------(...) |
     |                 ‚Üê‚Üí                                                                                     |
     |                 10¬µs                                                                                   |
     |________________________________________________________________________________________________________|
     |                          8 pulsos                                                                      |
     | Pulsos               ‚îå‚îê‚îå‚îê‚îå‚îê‚îå‚îê‚îå‚îê‚îå‚îê‚îå‚îê‚îå‚îê                  TIMEOUT_US = 20000¬µs     ‚îå‚îê‚îå‚îê‚îå‚îê‚îå‚îê‚îå‚îê‚îå‚îê‚îå‚îê‚îå‚îê       |
     | ultrass√¥nicos        ||||||||||||||||                            ‚Üì              ||||||||||||||||       |
     | emitido      --------‚îò‚îî‚îò‚îî‚îò‚îî‚îò‚îî‚îò‚îî‚îò‚îî‚îò‚îî‚îò‚îî----------------------(...)---(...)--------‚îò‚îî‚îò‚îî‚îò‚îî‚îò‚îî‚îò‚îî‚îò‚îî‚îò‚îî‚îò‚îî-(...) |
     | pelo HC_SR04         ‚Üê‚Üí                                                                                |
     |                 40kHz = 25¬µs                                                                           |
     |                      ‚Üê---------------‚Üí                                                                 |
     |                             200¬µs                                                                      |
     |________________________________________________________________________________________________________|
     |                                                                                                        |
     | Pino                                  ‚îå----------------‚îêTIMEOUT_US = 20000¬µs                           |
     | ECHO                                  |                |          ‚Üì                                    |
     | HC_SR04      -------------------------‚îò                ‚îî----(...)---(...)------------------------(...) |
     |                                                                                                        |
     |________________________________________________________________________________________________________|
  
  ```
  
  Como `TIMEOUT_US = 20000`, ent√£o o sensor identifica dist√¢ncias menores que aproximadamente 3,5m com esse c√≥digo utilizado:
  
  ![Dist√¢ncia](https://i.imgur.com/wkEWmOA.png)
  
</details>

---

#### 14/10/2025

üíæ [C√≥digo vers√£o 2](https://gist.github.com/parodrigues-ipynb/5a684ad0ee756691a03b47f6cd5c61a2)

üé• [V√≠deo B1-M1 rodando com a vers√£o 2](https://imgur.com/a/dLxYKjw)

Nesta vers√£o foi feita a substitui√ß√£o da fun√ß√£o `analogWrite()` pelas fun√ß√µes `ledcAttach()` e `ledcWrite()`.

A fun√ß√£o `analogWrite()` √© uma fun√ß√£o padr√£o a API Arduino, mas n√£o √© nativa na plataforma ESP32. Na ESP32, a fun√ß√£o `analogWrite()` √© apenas um *wrapper* (camada de compatibilidade) que chama o sistema PWM por hardware (LEDC).

Decidiu-se utilizar o LEDC j√° que ela √© nativa da ESP32 e j√° familiariza os alunos com as fun√ß√µes.

√â poss√≠vel controlar frequ√™ncia e resolu√ß√£o com `analogWrite()` atrav√©s de `analogWriteFrequency()` e `analogWriteResolution()`. Por√©m, esse controle afeta todos os canais PWM simultaneamente. A vantagem do LEDC √© que ele permite especificar frequ√™ncias e resolu√ß√µes distintas para cada canal.

<details>
  <summary>üìù Coment√°rios sobre o c√≥digo vers√£o 2 [clique para expandir]</summary>

  LEDC (*LED Control*) √© um perif√©rico de hardware interno da ESP32 projetado parar gerar sinais PWM com alta precis√£o e baixo uso da CPU.

  Esse perif√©rico permite at√© **16 canais PWM independentes** e **8 temporizadores** que definem a frequ√™ncia (de 1Hz at√© 40MHz) e resolu√ß√£o (de 1 at√© 20 bits) compartilhadas entre canais.

  Uma das grandes vantagens √© que esse perif√©rico mant√©m o sinal PWM ativo sem interven√ß√£o do processador. Ou seja, mesmo que a CPU fique sobrecarregada com fun√ß√µes de Wi-Fi, o sinal PWM permanecer√° est√°vel.

  ```ino
  const unsigned long TIMEOUT_US = 20000 // [¬µs]
  ```

  `TIMEOUT_US` foi transformada em uma vari√°vel pois h√° a vontade de calcular o seu valor com base em outros par√¢metros e `#define` n√£o faz c√°lculos com `floats` corretamente. O resultado da divis√£o de macros √© `int` - o que pode comprometer o funcionamento do c√≥digo de forma inesperada.

  ```ino
  // Configura√ß√£o PWM para uso do LEDC
  #define LEDC_FREQUENCIA_BASE_PWM 5000 // [Hz] Frequ√™ncia do PWM
  #define LEDC_RESOLUCAO_BIT_PWM 8     // [bits] Resolu√ß√£o (caso o valor seja 8, ent√£o a resolu√ß√£o √© de 0-255 pois 2^8 = 256)
  ```
  Foi acrescentado o bloco de c√≥digo acima nas defini√ß√µes para configurar o LEDC.
  
  `LEDC_FREQUENCIA_BASE_PWM` define a frequ√™ncia que ser√° utilizada nos canais dos sinais PWM. O valor de 5kHz √© comumente utilizado para motores DC. Frequ√™ncias muito baixas, como 50Hz, fazem o motor gerar um zumbido aud√≠vel. Frequ√™ncias muito altas, como 50kHz, aumentam a perda de pot√™ncia no driver motor TB6612FNG.
  
  ```ino
  void setup() {
    pinMode(AIN1, OUTPUT);
    pinMode(AIN2, OUTPUT);
    pinMode(BIN1, OUTPUT);
    pinMode(BIN2, OUTPUT);
    ledcAttach(PWMA, LEDC_FREQUENCIA_BASE_PWM, LEDC_RESOLUCAO_BIT_PWM);
    ledcWrite(PWMA, 0);
    ledcAttach(PWMB, LEDC_FREQUENCIA_BASE_PWM, LEDC_RESOLUCAO_BIT_PWM);
    ledcWrite(PWMB, 0);
    pinMode(STBY, OUTPUT);
  
    digitalWrite(STBY, HIGH); // Ativa o driver motor
  
    pinMode(TRIG, OUTPUT);
    pinMode(ECHO, INPUT);
  }
  ```

  As linhas `pinMode(PWMA, OUTPUT)` e `pinMode(PWMB, OUTPUT)` foram removidas do `void setup()`. Foram inseridas nos seus lugares as fun√ß√µes `ledcAttach()` para configurar os pinos PWM de cada motor e `ledcWrite()` para iniciar esses sinais PWM com *duty cycle* de 0%.

  ```ino
  void moverFrente() {
    digitalWrite(AIN1, HIGH);
    digitalWrite(AIN2, LOW);
    digitalWrite(BIN1, HIGH);
    digitalWrite(BIN2, LOW);
    ledcWrite(PWMA, pwmA);
    ledcWrite(PWMB, pwmB);
  }
  
  void parar() {
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, LOW);
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, LOW);
    ledcWrite(PWMA, 0);
    ledcWrite(PWMB, 0); 
  }
  ```

  Tanto nas fun√ß√µes `void moverFrente()` quanto `void parar()`, as linhas utilizando `analogWrite()` foram substitu√≠das por `ledcWrite()`.

</details>

---

#### 15/10/2025

üíæ [C√≥digo vers√£o 3](https://gist.github.com/parodrigues-ipynb/389f387e5dbd8301c90e3fee4f395897)

üé• [V√≠deo B1-M1 rodando com a vers√£o 3](https://imgur.com/a/VA4kzjJ)

Nesta vers√£o as ocorr√™ncias de `delay()` foram substitu√≠das por `millis()`.

O uso de t√©cnicas como a do `millis()` √© o padr√£o para sistemas embarcados que precisam reagir a m√∫ltiplos eventos em tempo real, como √© o caso do B1-M1.

`delay()` seria um gargalo para o funcionamento do B1-M1 pois essa √© uma fun√ß√£o **bloqueante**. Isso significa que outras tarefas n√£o ser√£o executadas durante a espera instaurada por `delay()`: o programa ir√° ficar "travado" naquele ponto por aquela dura√ß√£o de tempo - o que √© invi√°vel para uma premissa multitarefas.

Foram consultados os excelentes artigos abaixo para aprender mais sobre as boas pr√°ticas de utiliza√ß√£o da fun√ß√£o `millis()`.

üìî [Artigo "Usando millis() para contagem de tempo - Uma introdu√ß√£o para iniciantes"](https://forum.arduino.cc/t/using-millis-for-timing-a-beginners-guide/483573)

üìî [Artigo "C√≥digo de demonstra√ß√£o para diversas coisas que ocorrem simultaneamente"](https://forum.arduino.cc/t/demonstration-code-for-several-things-at-the-same-time/217158/2)

<details>
  <summary>üìù Coment√°rios sobre o c√≥digo vers√£o 3 [clique para expandir]</summary>

  ```ino
  unsigned long intervaloLeituras = 200; // [ms]
  unsigned long ultimoMillis = 0;        // [ms]
  ```

  Foram criadas duas vari√°veis do tipo `unsigned long` para trabalhar em conjunto com a l√≥gica de controle temporal atrav√©s do `millis()`.

  O uso de `unsigned long` √© importante pois esse √© o tipo de vari√°vel usado internamente por `millis()`.

  ```ino
  void loop() {
    unsigned long agora = millis(); // [ms]
  
    if (agora - ultimoMillis >= intervaloLeituras) {
      ultimoMillis = agora;
  
        float distancia = medirDistancia(); // [cm]
  
      if (distancia > DISTANCIA_MINIMA_CM) {
        moverFrente();
      } else {
        parar();
      }
    }
  }
  ```

  Essa modifica√ß√£o remove o `delay(200)` da fun√ß√£o `void loop()` e coloca a l√≥gica de `millis()` no seu lugar.

  O j√° mencionado [artigo "Usando millis() para contagem de tempo - Uma introdu√ß√£o para iniciantes"](https://forum.arduino.cc/t/using-millis-for-timing-a-beginners-guide/483573) tem uma explica√ß√£o muito boa sobre essa l√≥gica.
  
</details>

---

#### 15/10/2025

üíæ [C√≥digo vers√£o 4](https://gist.github.com/parodrigues-ipynb/aec2492d27c355218dc54208086fcc25)

üé• [V√≠deo B1-M1 rodando com a vers√£o 4](https://imgur.com/a/nlTqG0y)

Nesta vers√£o houve melhoria na robustez da fun√ß√£o `medirDistancia()`, que passou a fazer uma amostragem de 5 leituras e retornar a m√©dia dessas leituras. Isso √© uma filtragem simples.

Al√©m disso, os macros `VELOCIDADE_SOM_CM_US`, `DISTANCIA_MINIMA_CM`, `DISTANCIA_MAXIMA_CM` e `TIMEOUT_US` foram promovidos a vari√°veis (parab√©ns para eles üéâ).

O motivo desta altera√ß√£o √© que esses valores participam ou participar√£o em c√°lculos realizados ao longo do projeto. Por conta disso, o grupo desejou ter controle sobre o tipo dessas vari√°veis para ter mais previsibilidade sobre os resultados das opera√ß√µes matem√°ticas e tipos (`int`, `long`, `float`...) desses resultados.

<details>
  <summary>üìù Coment√°rios sobre o c√≥digo vers√£o 4 [clique para expandir]</summary>

  ```ino
  // HC-SR04 - Sensor de dist√¢ncia
  #define TRIG 27
  #define ECHO 14
  constexpr float VELOCIDADE_SOM_CM_US = 0.0343;   // [cm/¬µs] Velocidade do som a 20¬∞C
  constexpr float DISTANCIA_MINIMA_CM = 30;        // [cm]
  constexpr float DISTANCIA_MAXIMA_CM = 100;       // [cm]
  constexpr unsigned long TIMEOUT_US = 20000;      // [¬µs]
  constexpr uint8_t NUMERO_AMOSTRAS = 5;           // [amostras] Quantidade de leituras que o HC-SR04 coleta para fazer a m√©dia em uma filtragem simples
  constexpr uint8_t INTERVALO_ENTRE_AMOSTRAS = 10; // [ms] Tempo de espera entre cada leitura para que o som possa se dissipar e n√£o gere ru√≠do
  ```
  As vari√°veis `NUMERO_AMOSTRAS` e `INTERVALO_ENTRE_AMOSTRAS` foram criadas como par√¢metros para a fun√ß√£o `medirDistancia()`.
  
  O valor de 5 amostras foi escolhido por ser um equil√≠brio bom entre estabilidade e tempo de resposta.

  O valor de 10ms para tempo de espera foi escolhido para permitir a dissipa√ß√£o das ondas sonoras no ambiente antes de emitir um novo pulso ultrass√¥nico.

  ```ino
  float medirDistancia() {
    float somaDistancias = 0;
  
    for(int i = 0; i < NUMERO_AMOSTRAS; i++) {
      // Dispara pulso ultrass√¥nico
      digitalWrite(TRIG, LOW);
      delayMicroseconds(2);
      digitalWrite(TRIG, HIGH);
      delayMicroseconds(10);
      digitalWrite(TRIG, LOW);
  
      // Calcula a dist√¢ncia de cada amostra e soma
      long duracao = pulseIn(ECHO, HIGH, TIMEOUT_US);
      float distancia = duracao * VELOCIDADE_SOM_CM_US / 2; // [cm]
      somaDistancias += distancia;
  
      // Espera utilizando millis() para que o som possa se dissipar e n√£o afete leituras futuras
      unsigned long inicioEspera = millis();
      while (millis() - inicioEspera < INTERVALO_ENTRE_AMOSTRAS) {
        yield();
      }
    }
  
    float media = somaDistancias / NUMERO_AMOSTRAS;
    return media;
  }
  ```
  Foi criada a vari√°vel `somaDistancias` e toda a l√≥gica anterior da fun√ß√£o `medirDistancia()` foi colocada dentro do la√ßo de repeti√ß√£o `for(int i = 0; i < NUMERO_AMOSTRAS; i++)`.

  O uso do la√ßo `for()` ainda n√£o √© a solu√ß√£o ideal para um rob√¥ multitarefas como o B1-M1 em fun√ß√£o de propriedades semi-bloqueantes do `for()`, mas o grupo quis apenas validar a filtragem simples nessa vers√£o.

  O la√ßo `while (millis() - inicioEspera < INTERVALO_ENTRE_AMOSTRAS)` foi inserido para evitar ru√≠do nas leituras.

</details>

---

#### 15/10/2025

üíæ [C√≥digo vers√£o 5](https://gist.github.com/parodrigues-ipynb/b011a81d9a11b35db54fa2a64b99e691)

üé• [V√≠deo B1-M1 rodando com a vers√£o 5](https://imgur.com/a/nlTqG0y)

Nesta vers√£o foi introduzida uma l√≥gica de tratamento de ru√≠dos na fun√ß√£o `medirDistancia()`.

A vari√°vel `TIMEOUT_US` passou a ter um valor din√¢mico com base nas vari√°veis `DISTANCIA_MAXIMA_CM` e `VELOCIDADE_SOM_CM_US`.

<details>
  <summary>üìù Coment√°rios sobre o c√≥digo vers√£o 5 [clique para expandir]</summary>

  ```ino
  float medirDistancia() {
    float somaDistancias = 0;
    uint8_t leiturasValidas = 0;
  
    for (int i = 0; i < NUMERO_AMOSTRAS; i++) {
      // Dispara pulso ultrass√¥nico
      digitalWrite(TRIG, LOW);
      delayMicroseconds(2);
      digitalWrite(TRIG, HIGH);
      delayMicroseconds(10);
      digitalWrite(TRIG, LOW);
  
      // Calcula a dist√¢ncia de cada amostra e soma
      long duracao = pulseIn(ECHO, HIGH, TIMEOUT_US);       // [¬µs]
      float distancia = duracao * VELOCIDADE_SOM_CM_US / 2; // [cm]
  
      // Verifica a validez da leitura
      if (duracao > 0 && distancia >= 2 && distancia <= DISTANCIA_MAXIMA_CM) {
        somaDistancias += distancia;
        leiturasValidas++;
      }
      
      // Espera utilizando millis() para que o som possa se dissipar e n√£o afete leituras futuras
      unsigned long inicioEspera = millis();
      while (millis() - inicioEspera < INTERVALO_ENTRE_AMOSTRAS) {
        yield();
      }
    }
  
    if (leiturasValidas == 0) {
      return -1;
    }
  
    float media = somaDistancias / leiturasValidas;
    return media;
  }
  ```
  Para realizar o tratamento de erros, foi criada a vari√°vel `uint8_t leiturasValidas` para contabilizar a quantidade de amostras v√°lidas durante a execu√ß√£o de `medirDistancia()`.
  
  Uma leitura/amostra √© considerada v√°lida se:
  - a vari√°vel `duracao` for maior que 0¬µs. O valor de `duracao` √© determinado pela fun√ß√£o `pulseIn() e √© relativo √† dura√ß√£o de tempo em que ECHO permaneceu em n√≠vel HIGH;
  - a vari√°vel `distancia` for maior ou igual a 2cm. O valor √© calculado com base na `duracao` e na `VELOCIDADE_SOM_CM_US`;
  - a vari√°vel `distancia` for maior ou igual a `DISTANCIA_MAXIMA_CM`.
  
  A seguinte interpreta√ß√£o das leituras foi considerada
  
  | Situa√ß√£o                                              | Interpreta√ß√£o do B1-M1  | A√ß√£o B1-M1 |
  |-------------------------------------------------------|-------------------------|------------|
  | `leiturasValidas = 0`                                 | Os obst√°culos est√£o mais distantes que `DISTANCIA_MAXIMA_CM` (at√© onde o B1-M1 "enxerga"), o √¢ngulo de reflex√£o √© desfavor√°vel ou h√° um problema muito grave com as leituras. Enfim, o B1-M1 assume uma postura otimista e considera o caminho como livre  | `distancia == -1` ‚Üí `moverFrente()` |
  | `0 < leiturasValidas < 5`                             | O B1-M1 j√° √© capaz de detectar quando houve falhas de leitura, mas apenas as descarta por enquanto. O tratamento de erros est√° mais "refinando" o valor de `media` por enquanto | `distancia > DISTANCIA_MINIMA_CM` ‚Üí `moverFrente()` |
  | `distancia <= DISTANCIA_MINIMA_CM && distancia != -1` | Algum obst√°culo est√° nas imin√™ncias do B1-M1, ent√£o ele deve parar | `parar()` |

  ```ino
  constexpr unsigned long TIMEOUT_US = (2 * DISTANCIA_MAXIMA_CM) / VELOCIDADE_SOM_CM_US; // [¬µs] Limite de tempo de aguardo por eco
  ```
  A vari√°vel `TIMEOUT_US` agora √© calculada dinamicamente. Isso permite maior flexibilidade no c√≥digo no momento de altera√ß√£o de par√¢metros.

</details>
  
---

#### 16/10/2025

üíæ [C√≥digo vers√£o 6](https://gist.github.com/parodrigues-ipynb/9d698c0b5be52341f351f407901ce06d)

üé• [V√≠deo B1-M1 rodando com a vers√£o 6](https://imgur.com/a/DJXzT0k)

Nesta vers√£o foram adicionadas as vari√°veis, fun√ß√µes e trechos de c√≥digos em `void setup()` e `void loop()` para come√ßar a fazer uso dos sensores de velocidade encoder LM393.

üìî [Artigo "Liga√ß√£o entre encoder LM393 e Arduino para medir √¢ngulo e velocidade angular"](https://aleksandarhaber.com/interface-lm393-encoder-with-arduino-and-measure-the-angle-and-angular-velocity/)

<details>
  <summary>üìù Coment√°rios sobre o c√≥digo vers√£o 6 [clique para expandir]</summary>

  ```ino
  // LM393 - Sensor de velocidade
  #define SENSOR_VELOCIDADE_MOTOR_A 34
  #define SENSOR_VELOCIDADE_MOTOR_B 35
  volatile unsigned long pulsosMotorA = 0;
  volatile unsigned long pulsosMotorB = 0;
  ```
  Foram definidos os pinos GPIO 34 e 35 atrav√©s das diretivas `SENSOR_VELOCIDADE_MOTOR_A` e `SENSOR_VELOCIDADE_MOTOR_B` para receber os sinais dos pinos D0 dos sensores de velocidade dos motores A e B.

  As vari√°veis `pulsosMotorA` e `pulsosMotorB` s√£o contadores de pulso.

  Quando o disco furado encoder gira os sensores infravermelhos passam a "ligar e desligar" - √†s vezes a luz infravermelha atravessa um furo do disco, √†s vezes √© interrompida por uma das paredes do disco. Um pulso √© justamente a transi√ß√£o de "ligado para desligado" ou "desligado para ligado". Mais para frente no c√≥digo √© definido como √© contabilizado o pulso: se √© na borda de descida (ligado para desligado) ou subida (desligado para ligado).

  Como os valores dessas vari√°veis podem ficar muito grandes, o tipo `unsigned long` foi adotado.

  Como s√£o utilizadas fun√ß√µes de interrup√ß√£o para contabilizar `pulsosMotorA` e `pulsosMotorB`, o tipo `volatile` deve indicar ao compilador que essas vari√°veis podem ser modificadas fora do fluxo normal do programa. üìº [Esse v√≠deo](https://www.youtube.com/watch?v=QtyOiTw0oQc) ajudou os alunos a compreender melhor o conceito de interrup√ß√µes. O trecho de c√≥digo a seguir mostra essas fun√ß√µes em si.

  ```ino
  void IRAM_ATTR contarPulsosMotorA() { pulsosMotorA++; }
  void IRAM_ATTR contarPulsosMotorB() { pulsosMotorB++; }
  ```

  O atributo `IRAM_ATTR` √© espec√≠fico da ESP32 e serve para indicar ao compilador que a fun√ß√£o deve ser armazenada na IRAM (*internal RAM*, ou *mem√≥ria RAM interna*, se for permitido o pleonasmo). "ATTR" vem de *attribute*, que traduzido do Ingl√™s significa *atributo*.

  O atributo `IRAM_ATTR` √© necess√°rio para que as fun√ß√µes `contarPulsosMotorA()` e `contarPulsosMotorB()` sejam executadas imediatamente quando o evento ocorre. Abaixo √© especificado qual √© o evento.

  ```ino
  // LM393 - Sensor de velocidade encoder
  pinMode(SENSOR_VELOCIDADE_MOTOR_A, INPUT);
  pinMode(SENSOR_VELOCIDADE_MOTOR_B, INPUT);
  attachInterrupt(digitalPinToInterrupt(SENSOR_VELOCIDADE_MOTOR_A), contarPulsosMotorA, RISING);
  attachInterrupt(digitalPinToInterrupt(SENSOR_VELOCIDADE_MOTOR_B), contarPulsosMotorB, RISING);
  ```

  Essas linhas foram inseridas em `void setup()` e dizem ao compilador quais s√£o os eventos que devem fazer ele executar as fun√ß√µes `contarPulsosMotorA()` e `contarPulsosMotorB()`: uma borda de subida (RISING) nos pinos `SENSOR_VELOCIDADE_MOTOR_A` e `SENSOR_VELOCIDADE_MOTOR_B`.

  ```ino
  // LM393 - Sensor de velocidade encoder
  unsigned long pulsosA = pulsosMotorA;
  unsigned long pulsosB = pulsosMotorB;
  pulsosMotorA = 0;
  pulsosMotorB = 0;
  ```

  Por fim, houve a adi√ß√£o desse bloco em `void loop()`.
  
  Os valores dos pulsos dos sensores s√£o armazenados e zerados a cada ciclo de `loop()` pois estamos medindo apenas a velocidade instant√¢nea dos motores e n√£o a dist√¢ncia percorrida - situa√ß√£o na qual dever√≠amos verificar o total acumulado.
  
</details>

---

#### 16/10/2025

üíæ [C√≥digo vers√£o 7](https://gist.github.com/parodrigues-ipynb/17f40759919c51057b26ca906bcfb080)

üé• [V√≠deo B1-M1 rodando com a vers√£o 7](https://imgur.com/a/xP080Ys)

Nesta vers√£o foram adicionadas vari√°veis e fun√ß√µes de movimento al√©m de apenas andar para frente e parar.

O controle temporal dos testes das fun√ß√µes de movimento foi implementado utilizando `millis()` para refo√ßar o aprendizado dos conceitos

<details>
  <summary>üìù Coment√°rios sobre o c√≥digo vers√£o 7 [clique para expandir]</summary>

  ```ino
  void moverTras() {
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, HIGH);
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, HIGH);
    ledcWrite(PWMA, pwmA);
    ledcWrite(PWMB, pwmB);
  }
  
  void girarEsquerda() {
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, HIGH);
    digitalWrite(BIN1, HIGH);
    digitalWrite(BIN2, LOW);
    ledcWrite(PWMA, pwmA);
    ledcWrite(PWMB, pwmB);
  }
  
  void girarDireita() {
    digitalWrite(AIN1, HIGH);
    digitalWrite(AIN2, LOW);
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, HIGH);
    ledcWrite(PWMA, pwmA);
    ledcWrite(PWMB, pwmB);
  }
  ```
  Estas foram as fun√ß√µes de movimento adicionadas.

  As fun√ß√µes `girarEsquerda()` e `girarDireita()` fazem o B1-M1 girar no ponto em que ele est√° no sentido especificado.

  ```ino
  // Controle do movimento temporizado para tr√°s
  unsigned long tempoInicioTras = 0;     // [ms] Registro temporal do momento em que o B1-M1 come√ßou o movimento para tr√°s
  unsigned long duracaoTras = 1000;      // [ms] Tempo de dura√ß√£o do movimento para tr√°s
  bool movendoTras = false;              // Flag para l√≥gica do movimento para tr√°s
  
  // Controle do movimento temporizado de giro
  unsigned long tempoInicioGiro = 0;     // [ms] Registro temporal do momento em que o B1-M1 come√ßou o giro
  unsigned long duracaoGiro = 700;       // [ms] Tempo de dura√ß√£o do movimento de giro
  bool movendoGiro = false;              // Flag para l√≥gica do movimento de giro
  ```
  Foram adicionadas as vari√°veis acima para controle temporal dos movimentos.

  ```ino
  void loop() {
    unsigned long agora = millis(); // [ms]
  
    // [TESTE MOVIMENTO] Verifica√ß√£o do movimento para tr√°s
    if (movendoTras) {
      if (agora - tempoInicioTras >= duracaoTras) {
        girarEsquerda();
        movendoTras = false;
        movendoGiro = true;
        tempoInicioGiro = agora;
      }
      return;
    }
  
    // [TESTE MOVIMENTO] Verifica√ß√£o do movimento de giro
    if (movendoGiro) {
      if (agora - tempoInicioGiro >= duracaoGiro) {
        parar();
        movendoGiro = false;
      }
      return;
    }
  
    if (agora - ultimoMillis >= intervaloLeituras) {
      ultimoMillis = agora;
      
      float distancia = medirDistancia(); // [cm]
  
      // LM393 - Sensor de velocidade encoder
      noInterrupts();
      unsigned long pulsosA = pulsosMotorA;
      unsigned long pulsosB = pulsosMotorB;
      pulsosMotorA = 0;
      pulsosMotorB = 0;
      interrupts();
  
      if (pulsosA > 5 && pulsosB > 5) {
        if (distancia > DISTANCIA_MINIMA_CM || distancia == -1) {
          moverFrente();
        } else {
          girarDireita();
        }
      } else {
        moverTras();
        movendoTras = true;
        tempoInicioTras = agora;
      }
    }
  }
  ```
  Os blocos `if (movendoTras)` e `if(movendoGiro)` foram adicionados ao `void looop()` para checar o estado (`movendoTras` ou `movendoGiro`) em que o B1-M1 est√° a cada ciclo de `loop()`.

  √â assumido na l√≥gica do `loop()` que o B1-M1 est√° sempre andando para frente chamando a fun√ß√£o `moverFrente()`. Portanto, n√£o h√° checagem para esse estado neste teste.

  `noInterrupts()` e `interrupts()` foram fun√ß√µes utilizadas para realizar compara√ß√µes l√≥gicas com as vari√°veis `pulsosA` e `pulsosB`. O uso delas faz com que os valores de pulsos n√£o mudem durante a atribui√ß√£o, uma vez que eles s√£o determinados por interrup√ß√µes e poderiam ter valores ligeiramente diferentes.

  `if (pulsosA > 5 && pulsosB > 5)` foi a l√≥gica utilizada para detectar colis√µes com objetos que estavam em √¢ngulo desfavor√°vel em rela√ß√£o ao sensor ultrass√¥nico HC-SR04 ou fora da altura dele. A ideia por tr√°s foi "se ambos motores estiverem com um giro apropriado, continue em frente. Se pelo menos um dos motores tiver um giro muito baixo ou 0, mova-se para tr√°s, gire e volte a ir para frente".

</details>

---

#### 17/10/2025 e 18/10/2025

Nestes dias foi definida a estrat√©gia de comunica√ß√£o e acesso remoto do B1-M1.

A ESP32-CAM foi configurada e o seu funcionamento instalada no B1-M1 foi posto √† prova.

üé• [V√≠deo B1-M1 rodando com c√¢mera ESP32-CAM fazendo streaming](https://imgur.com/a/8KsLpTI)

<details>
  <summary>üìù Memorial das estrat√©gias adotadas [clique para expandir]</summary>

  Os objetivos do B1-M1 s√£o:
  1. mover-se seguindo uma rotina pr√©-determinada em um ambiente residencial plano e permitir controle remoto;
  2. registrar valores obtidos pelo sensoriamento ultrass√¥nico e visual (fotografias) e permitir o stream (v√≠deo) durante o acesso remoto;
  3. comunicar-se com o Gemini atrav√©s da API fornecida pelo Google a fim de obter instru√ß√µes para movimento aut√¥nomo.
  
  At√© essa sexta-feira chuvosa, o objetivo 1 est√° quase conclu√≠do: o B1-M1 j√° consegue receber rotinas e movimentar-se sozinho, mesmo que de maneira muito simples ainda.
  
  Por√©m, o B1-M1 ainda n√£o consegue receber controle remoto via web. Ele tamb√©m ainda n√£o realiza telemetria e nem tem a ESP32-CAM configurada para realizar streaming.
  
  Foi feita uma pesquisa para definir a estrat√©gia de comunica√ß√£o e acesso remoto que o B1-M1. Procurou-se utilizar op√ß√µes simples que permitissem ao grupo avan√ßar nos objetivos e compreender cada etapa realizada.
  
  Foi definido que:
  * a ESP32 ser√° configurada em modo Wi-Fi STA (cliente) e ser√° conectada a um roteador Wi-Fi, servindo de ponto de acesso remoto;
  * a ESP32 ser√° respons√°vel por hospedar o servidor WebSocket, servindo uma p√°gina HTML que exibe os dados de telemetria, a stream da ESP32-CAM e envia comandos em tempo real;
  * a ESP32-CAM ir√° transmitir o streaming de v√≠deo via Wi-Fi na porta 81;
  * tanto a ESP32 quanto a ESP32-CAM **funcionar√£o localmente** numa mesma rede Wi-Fi;
  * ser√° criado um t√∫nel HTTPS remoto com a ferramenta [ngrok](https://ngrok.com/) para possibilitar o acesso remoto sem precisar configurar roteador;
  * o usu√°rio acessa `http://<ip_esp32>/` e a p√°gina HTML exibe o v√≠deo vindo da ESP32-CAM via `<img src="http://<ip_esp32-cam>:81/stream">`;
  * o WebSocket envia comandos e recebe telemetria em tempo real.
  
  O fluxo adotado foi:
  ```
  Usu√°rio (browser) ‚Üí T√∫nel HTTPS ‚Üí Roteador ‚Üí ESP32 (WebSocket e controle dos motores e sensores)
                                      ‚Üì
                         ESP-32CAM (v√≠deo MJPEG)
  ```

  ![Configura√ß√µes ArduinoIDE](https://i.imgur.com/58JCrel.jpeg)
  
  As seguintes configura√ß√µes foram utilizadas no ArduinoIDE para programa√ß√£o da ESP32-CAM:
  * `Tools ‚Üí CPU Frequency: "240MHz (WiFi/BT)"`
  * `Tools ‚Üí Flash Frequency: "80MHz"`
  * `Tools ‚Üí Partition Scheme: "Huge APP (3MB No OTA/1MB SPIFFS)"`
  
  A board `AI Thinker ESP32-CAM` foi utilizada. Ela veio junto no pacote `esp32` da Espressif Systems no Boards Manager (`CTRL+SHIFT+B`) do ArduinoIDE.

  ![Bibliotecas ESP32 no ArduinoIDE](https://i.imgur.com/byRoTxa.jpeg)
  
  A biblioteca da ESP32 foi inserida da seguinte forma no ArduinoIDE:
  * `File ‚Üí Preferences`, e ent√£o na linha `Additional boards manager URLs:` foi inserido `https://dl.espressif.com/dl/package_esp32_index.json`. Tamb√©m foi inserido `https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json`.
  
  Com a board `AI Thinker ESP32-CAM` selecionada no ArduinoIDE, em `File ‚Üí Examples ‚Üí ESP32 ‚Üí Camera ‚Üí CameraWebServer` √© poss√≠vel localizar o exemplo base utilizado para programar a ESP32-CAM.
  
  Na aba `board_config.h` foi selecionada a board `#define CAMERA_MODEL_AI_THINKER // Has PSRAM` tirando essa linha dos coment√°rios e deixando as demais comentadas.
  
  Na aba `CameraWebServer.ino` foram inseridos os credenciais da rede Wi-Fi local nas vari√°veis `const char *ssid` e `const char *password`.
  
  A vari√°vel `config.frame_size` teve seu valor ajustado para `FRAMESIZE_QVGA`. Esse *framesize* √© apropriado para uma transmiss√£o r√°pida e sem muita qualidade - ideal para o projeto.

  Logo abaixo da linha `sensor_t *s = esp_camera_sensor_get();` foram inseridas essas duas linhas:
  ```ino
  s->set_vflip(s, 1);
  s->set_hmirror(s, 1);
  ```

  Essas linhas s√£o respons√°veis por fazer a imagem captada pela c√¢mera espelhar vertical e horizontalmente.

  ![Jumper entre GPIO0 e GND](https://i.imgur.com/QdL94Oa.jpeg)
  
  A ESP32-CAM foi conectada ao computador por cabo e um jumper foi colocado entre os pinos GPIO0 e GND, conforme a imagem acima. Ap√≥s pressionar o bot√£o `Upload` na ArduinoIDE, o bot√£o `Flash` da ESP32-CAM foi pressionado brevemente ap√≥s a compila√ß√£o do ArduinoIDE completar para iniciar o modo flash da ESP32-CAM.

  üé• [O processo descrito acima pode ser verificado nesse v√≠deo](https://imgur.com/a/ZGpJELn)

  Depois de completo o flash, a ESP32-CAM imprimiu pelo monitor serial o IP `192.168.0.11`. Foi acessado o link `http://192.168.0.11:81/stream` para verificar se o streaming estava funcionando e, para nossa alegria, estava!

  ![Streaming funcionando](https://i.imgur.com/X4qUtl7.jpeg)

  A ESP32-CAM foi prontamente montada no B1-M1 e foi verificado se era poss√≠vel acessar o streaming enquanto o B1-M1 se movia.
  
  üé• [O v√≠deo do funcionamento da ESP32-CAM no B1-M1 pode ser visto aqui](https://imgur.com/a/8KsLpTI).
</details>

---

#### 19/10/2025

Nesta vers√£o foi implementado um WebServer na ESP32, que passou a hospedar uma p√°gina HTML que cont√©m o `<img src="http://<ip_esp32-cam>:81/stream">` para exibir o streaming da ESP32-CAM.

üíæ [C√≥digo vers√£o 8](https://gist.github.com/parodrigues-ipynb/481f91f52f6bb0200ce5ec6a1855c48b)

üé• [V√≠deo B1-M1 rodando com a vers√£o 8](https://imgur.com/a/bDEAqPS)

<details>
  <summary>üìù Coment√°rios sobre o c√≥digo vers√£o 8 [clique para expandir]</summary>

  ```ino
  #include <WiFi.h>
  #include <WebServer.h>
  
  // Configura√ß√µes rede Wi-Fi
  const char* SSID_REDE_WIFI = "Internet do Pedrinho 2.4 GHz";
  const char* SENHA_REDE_WIFI = "[conte√∫do removido]";
  const char* URL_STREAM_CAMERA = "http://192.168.0.11:81/stream";
  WebServer server(80);
  ```

  Foram inseridas as linhas acima no c√≥digo da ESP32 do B1-M1, junto com as bibliotecas `<WiFi.h>` e `<WebServer.h>`.

  As vari√°veis `SSID_REDE_WIFI`, `SENHA_REDE_WIFI` e `URL_STREAM_CAMERA` s√£o apenas par√¢metros constantes de configura√ß√£o. O ideal seria que essas informa√ß√µes estivessem em um arquivo `.cpp` separado, mas o grupo ainda n√£o aprendeu como implementar isso e n√£o √© algo crucial para a etapa atual.

  O tipo `const char*` √© um ponteiro para caracteres constante. Ele foi utilizado porque as fun√ß√µes da biblioteca `<WiFi.h>` (como `WiFi.begin()`) esperam esse tipo de vari√°vel, e n√£o objetos `String`. O uso de ponteiros evita convers√µes desnecess√°rias e economiza processamento.

  Para fins did√°ticos, cabe mencionar que ponteiros s√£o endere√ßos f√≠sicos de mem√≥ria. Eles indicam, portanto, uma √°rea fixa da mem√≥ria (geralmente a mem√≥ria flash j√° que essas vari√°veis foram declaradas com `const`). J√° `Strings` alocam mem√≥ria dinamicamente conforme s√£o alteradas ou atribu√≠das. Como microcontroladores geralmente t√™m pouca mem√≥ria RAM, ponteiros costumam ser mais eficientes e devem ser preferidos em casos como os das vari√°veis que armazenam o SSID, a senha e a URL da c√¢mera.

  H√° ainda outro tipo de vari√°vel para sequ√™ncias de caracteres: o `char[]`, que cria vetores. Por exemplo, `char [] SSID = "Internet do Pedrinho 2.4GHz";` criaria um vetor cujos elemntos seriam os caracteres do SSID: `I`, `n`, `t`, `e`, `r`, `n`, `e`, `t`, ` `, `d`, `o`,... e assim por diante. O √∫ltimo elemento desse vetor seria preenchido por `\0`  para indicar o final do vetor. Portanto, o endere√ßo f√≠sico apontado por `SSID` teria um valor ideal para armazenar o texto `Internet do Pedrinho 2.4GHz\0`.

  Talvez a SSID mude. Digamos que eu adquirisse a Internet do Pedrinho Um Bilh√£o GHz. Eu n√£o conseguiria utilizar o mesmo espa√ßo de mem√≥ria para armazenar esse novo valor de forma segura, sem o risco de sobrescrever outras informa√ß√µes importantes na mem√≥ria.

  Portanto, faz muito sentido que a biblioteca tenha essa predile√ß√£o por ponteiros: eles tornam o processo todo mais seguro, eficiente e pr√°tico.
  
  A linha `WebServer server(80)`  cria um objeto do tipo `WebServer` configurado para utilizar o protocolo HTTP da porta `80`.

  | Parte do c√≥digo  | Tipo                  | Fun√ß√£o                                                                                          |
  |------------------|-----------------------|-------------------------------------------------------------------------------------------------|
  | `WebServer`      | Classe de um objeto   | Molde ou tipo de dado que define as caracter√≠sticas ou comportamento de algo. Neste caso, a classe WebServer foi criada para lidar com as funcionalidades de um servidor web.    *Nota:* Esta classe est√° na biblioteca `<WebServer.h>` |
  | `server()`       | Nome do objeto        | `WebServer` √© o "molde para servidores". `server()` √© o servidor que estamos criando.             |
  | `80`             | Argumento ou par√¢metro| O n√∫mero `80` √© a porta padr√£o para tr√°fego de internet n√£o criptografado (*HTTP - HyperText Transfer Protocol*). Ao passar o argumento `80`, estamos instru√≠ndo o objeto `server()` a "ouvir" as requisi√ß√µes que chegam nessa porta. Quando um navegador web tenta se conectar √† ESP32 usando o endere√ßo IP dela, o navegador far√° isso na porta `80` por padr√£o, permitindo que a comunica√ß√£o entre o servidor e o cliente (navegador) seja estabelecida.    *Nota:* No contexto de redes de computadores, 'porta' √© um n√∫mero que identifica um servi√ßo ou aplica√ß√£o espec√≠fica em um computador ou dispositivo. D√° para pensar em 'porta' como sendo o 'n√∫mero da sala onde ocorrem determinadas atividades'. As portas s√£o essenciais pois permitem a um dispositivo responda diversas requisi√ß√µes em diferentes portas simultaneamente. Inclusive, a porta para HTTPS (tr√°fego criptografado, seguro) √© `443`. |
  
  **Exemplo pr√°tico**
  * Digamos que o IP da ESP32 seja `192.168.1.100`;
  * Se a gente digitar `http://192.168.1.100` em um navegador, esse navegador ir√° tentar, por padr√£o, se conectar √† porta `80` da ESP32;
  * O objeto `server()` na ESP32 ir√° "receber" ou "escutar" essa requisi√ß√£o e, dependendo do resto do c√≥digo, responder√° com uma p√°gina HTML ou
  outra informa√ß√£o qualquer.

  ```ino
  void handleRoot() {
    String html = R"rawliteral(
      <!DOCTYPE html>
        <html>
          <head>
            <meta charset = "utf-8">
            <title>B1-M1</title>
            <style>
              body { text-align: center; background-color: #222; color: white; }
              img { width: 90%; max-width: 480px; border: 2px solid #444; margin-top: 20px; }
            </style>
          </head>
          <body>
            <h2>Stream da ESP32-CAM</h2>
            <img src=")rawliteral";
            html += URL_STREAM_CAMERA;
            html += R"rawliteral(">
          </body>
        </html>
    )rawliteral";
  
    server.send(200, "text/html", html);
  }
  ```
  A fun√ß√£o `handleRoot()` foi criada para criar a p√°gina HTML exibida durante acessos ao WebServer da ESP32.

  Um *handler* √© uma fun√ß√£o criada para que um conjunto de a√ß√µes seja realizado quando diferentes rotas do WebServer forem acessadas.

  Por exemplo, a rota padr√£o (ou rota ra√≠z, *root* ou simplesmente `/`) da ESP32 √© `http://<IP-da-ESP32>/` (a `/` final √© o motivo de poder chamar a rota padr√£o de apenas `/`). O conjunto de a√ß√µes dentro da fun√ß√£o `handleRoot()` deve ser executado quando algum usu√°rio acessar a rota padr√£o.

  A fun√ß√£o come√ßa com uma `String` chamada `html` que cont√©m o c√≥digo HTML da p√°gina que desejamos exibir ao usu√°rio. O prefixo `R"rawliteral(...)rawliteral"` foi utilizado para facilitar a inclus√£o do bloco de c√≥digo HTML utilizando m√∫ltiplas linhas numa mesma `String`.

  A linha `server.send(200, "text/html", html);` √© t√≠pica em projetos de WebServer. 

  A fun√ß√£o `send()` √© chamada quando algum cliente (navegador) acessa a ra√≠z (*root*) do servidor web (WebServer) da ESP32 (exemplo: `http://192.168.0.10/`).
  
  | Parte do c√≥digo             | Tipo                  | Fun√ß√£o                                                                                          |
  |-----------------------------|-----------------------|-------------------------------------------------------------------------------------------------|
  |`.send(200,<>,<>)`           | C√≥digo de status HTTP | '200' significa 'OK'. Ou seja, a requisi√ß√£o de acesso √† *root* foi bem-sucedida.                  |
  |`.send(<>,"text/html",<>)`   | Defini√ß√£o do tipo de conte√∫do enviado ao navegador  | `text/html` √© o *MIME type* (ou *Content-Type*) que o servidor informa ao navegador sobre o tipo de dado que est√° sendo enviado na resposta. `text/html` diz ao navegador que o conte√∫do retornado √© um c√≥digo HTML e deve ser interpretado/renderizado como uma p√°gina web. |
  |`.send(<>, <>, html)`| Conte√∫do                      | Quando algum cliente acessar a p√°gina principal da ESP32 (ra√≠z, ou *root*, ou `/`), envia como resposta o c√≥digo de p√°gina HTML na vari√°vel `html` |

  ```ino
  void setup() {
    // Rede Wi-Fi
    Serial.begin(115200);
    WiFi.begin(SSID_REDE_WIFI, SENHA_REDE_WIFI);
    Serial.print("Conectando o B1-M1 √† rede Wi-Fi ");
    Serial.print(SSID_REDE_WIFI);
    while (WiFi.status() != WL_CONNECTED) {
      delay(500);
      Serial.print(".");
    }
    Serial.println("\nConex√£o estabelecida!");
    Serial.print("IP da ESP32: ");
    Serial.println(WiFi.localIP());
  
    server.on("/", handleRoot);
    server.begin();
    Serial.println("Servidor Wi-Fi do B1-M1 iniciado.");
  }
  ```
  As linhas acima foram adicionadas para iniciar a conex√£o Wi-Fi com a rede informada na vari√°vel `SSID_REDE_WIFI`.

  O IP da ESP32 √© impresso no monitor da comunica√ß√£o serial e ent√£o a linha `server.on("/", handleRoot)` configura que acessos de usu√°rios √† rota padr√£o devem chamar a fun√ß√£o `handleRoot()`.

  ```ino
  void loop() {
    unsigned long agora = millis(); // [ms]
  
    // ‚îå------------------------------------------‚îê
    // |  Controle de movimento e sensoriamento   |
    // ‚îî------------------------------------------‚îò
  
    // Verifica√ß√£o do movimento para tr√°s
    if (movendoTras) {
      ...
    }
  
    // Verifica√ß√£o do movimento de giro
    if (movendoGiro) {
      ...
    }
  
    if (agora - ultimoMillis >= intervaloLeituras) {
      ...
    }
  
    // ‚îå------------------------------------------‚îê
    // |  Processamento de requisi√ß√µes HTTP       |
    // ‚îî------------------------------------------‚îò
    server.handleClient();
  }
  ```
  A linha com o m√©todo `server.handleClient();` da biblioteca `<WebServer.h>` foi adicionada no final da fun√ß√£o `void loop()`. Ela faz o servidor receber as solicita√ß√µes dos usu√°rios (ou *clients*).
  
</details>

---

#### 19/10/2025

üíæ [C√≥digo vers√£o 9](https://gist.github.com/parodrigues-ipynb/5c16661706b89709aed75a170137865f)

üé• [V√≠deo B1-M1 rodando com a vers√£o 9](https://imgur.com/a/lSfCcor)

<details>
  <summary>üìù Coment√°rios sobre o c√≥digo vers√£o 9 [clique para expandir]</summary>

  ```ino
  #include <WiFi.h>
  #include <AsyncTCP.h>
  #include <ESPAsyncWebServer.h>
  
  // Configura√ß√µes rede Wi-Fi
  const char* SSID_REDE_WIFI = "Internet do Pedrinho 2.4 GHz";
  const char* SENHA_REDE_WIFI = "cachorronuclear";
  const char* URL_STREAM_CAMERA = "http://192.168.0.11:81/stream";
  AsyncWebServer server(80);
  AsyncWebSocket ws("/ws");
  bool modoManual = false; // Flag para verificar se algum usu√°rio do WebServer est√° no modo manual do B1-M1
  ```
  As bibliotecas `<AsyncTCP.h>` e `<ESPAsyncWebServer.h>` foram adicionadas no cabe√ßalho do c√≥digo do B1-M1.

  `<AsyncTCP.h>` implementa uma camada TCP ass√≠ncrona para a ESP32.

  TCP significa *Transmission Control Protocol*, ou *Protocolo de Controle de Transmiss√£o*. TCP √© o protocolo de transporte de dados usado pela internet para garantir que os dados enviados cheguem ao destino.
  
  Por exemplo, digamos que o navegador esteja enviando dados para a ESP32. Esses dados s√£o divididos em pacotes IP - pequenos blocos numerados que viajam por roteadores e redes diferentes at√© chegar ao destino, que √© a ESP32. Abaixo est√° uma imagem exemplo de um pacote.
  
  ![Pacote IP](https://i.imgur.com/5jAjZOZ.jpeg)
  
  A internet √© composta por milhares de roteadores e enlaces f√≠sicos (cabos, fibra, Wi-Fi, r√°dio...). Durante o transporte dos pacotes, falhas comuns e inevit√°veis em redes grandes como a internet s√£o:
  * os pacotes atrasarem (lat√™ncia);
  * os pacotes chegarem fora de ordem;
  * algum roteador descartar pacotes se estiver sobrecarregado (congestionamento);
  * alguma interfer√™ncia eletromagn√©tica corromper bits (erro de transmiss√£o);
  * conex√µes Wi-Fi falharem temporariamente em fun√ß√£o de sinal fraco ou ru√≠do.
  
  O TCP foi projetado para lidar com essas imperfei√ß√µes. Ele:
  * numera cada pacote para que o receptor saiba a ordem correta dos pacotes;
  * faz o destino confirmar o recebimento (ACK - *acknowledge*, ou *reconhecimento*) dos pacotes enviando mensagens como "recebi o pacote X";
  * se um tempo limite for excedido sem ACK desde o envio, faz o remetente reenviar pacotes n√£o reconhecidos;
  * verifica a integridade de cada pacote atrav√©s de uma [soma de verifica√ß√£o (*checksum*)](https://pt.wikipedia.org/wiki/Soma_de_verifica%C3%A7%C3%A3o);
  * remonta os dados no destino seguindo a ordem e garantindo a completude dos pacotes.
  
  Existem protocolos que n√£o aplicam controle de erros, como o UDP (*User Datagram Protocol*, ou *Protocolo de Datagrama do Usu√°rio*). O fato do envio n√£o depender de esperar confirma√ß√µes torna a comunica√ß√£o mais r√°pida.
  
  ![TCP vs. UDP](https://i.imgur.com/3Lm5mss.jpeg)
  
  Normalmente TCP √© utilizado para dados que n√£o podem se perder, enquanto que UDP √© usado para dados que podem ser descartados sem problemas.
  
  Em resumo,
  |Protocolo | Tipo          | Reenvia pacotes? | Ordem dos pacotes garantida? | Exemplo de uso                |
  |----------|---------------|:----------------:|:----------------------------:|-------------------------------|
  |TCP       | Confi√°vel     | Sim              | Sim                          | Web, WebSocket, HTTP          |
  |UDP       | N√£o confi√°vel | N√£o              | N√£o                          | Streaming, jogos online, VoIP |
  
  O meme abaixo ajudou os alunos a fixar o conte√∫do sobre UDP e TCP.
  
  ![Meme did√°tico](https://i.imgur.com/xA05ZFi.jpeg)

  J√° o termo "comunica√ß√£o ass√≠ncrona" significa que o programa n√£o espera que uma opera√ß√£o termine para continuar sua execu√ß√£o.

  Na comunica√ß√£o s√≠ncrona (bloqueante), o B1-M1 iria "congelar" durante a comunica√ß√£o, pois iria **esperar cada opera√ß√£o terminar para dar sequ√™ncia**. Quando ele atendesse a uma requisi√ß√£o da interface web, a ESP32 travaria momentaneamente a leitura dos sensores ultrass√¥nicos ou o controle dos motores A e B. Isso √© muito ruim para um rob√¥ multitarefas.

  Na comunica√ß√£o ass√≠ncrona (n√£o bloqueante), o B1-M1 continuaria ativo durante a comunica√ß√£o, pois iria **utilizar eventos** para chamar fun√ß√µes de callback somente no momento de chegada dos dados, sem travar o restante do c√≥digo durante o aguardo dos dados.

  Com a biblioteca `<AsyncTCP.h>` √© poss√≠vel manter o servidor HTTP aceitando conex√µes, manter os WebSockets recebendo comandos e manter o B1-M1 realizando o sensoriamento e controle dos motores.

  A biblioteca `<ESPAsyncWebServer.h>` √© a vers√£o ass√≠ncrona da `<WebServer.h>`.

  As linhas `AsyncWebServer server(80);` e `AsyncWebSocket ws("/ws");` inicializam objetos para cria√ß√£o do WebServer ass√≠ncrono e os WebSockets.

  WebSockets s√£o um protocolo de comunica√ß√£o bidirecional e cont√≠nua entre cliente e servidor. Eles operam sobre TCP.

  | Aspecto               | HTTP                                                       | WebSocket                                                                       |
  |-----------------------|------------------------------------------------------------|---------------------------------------------------------------------------------|
  | Modelo de comunica√ß√£o | Unidirecional / Requisi√ß√£o (Cliente) ‚Üí Resposta (Servidor) | Bidirecional                                                                    |
  | Conex√£o               | Abre e fecha a cada requisi√ß√£o                             | Conex√£o √∫nica e persistente                                                     |
  | Lat√™ncia              | Alta (*handshake* e cabe√ßalhos a cada requisi√ß√£o)          | Baixa (canal aberto ap√≥s o *handshake* inicial)                                 |
  | Uso t√≠pico            | P√°ginas web, APIs REST, requisi√ß√µes ocasionais             | Aplica√ß√µes em tempo real (chats, telemetria, jogos online, controle remoto)     |
  | Transporte            | HTTP/HTTPS                                                 | TCP (com *handshake* inicial via HTTP, depois muda de protocolo para WebSocket) |

  Ou seja, HTTP √© ideal para trocas ocasionais de dados (*pull*), enquanto que WebSocket √© projetado para comunica√ß√£o cont√≠nua e instant√¢nea (*push/pull* em tempo real).

  ```ino
  void onWsEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len) {
    if (type == WS_EVT_DATA) {
      String cmd = String((char*)data).substring(0, len);
      cmd.trim();
      Serial.println("Comando recebido: " + cmd);
  
      if (cmd == "frente") {
        modoManual = true;
        moverFrente();
      } else if (cmd == "tras") {
        modoManual = true;
        moverTras();
      } else if (cmd == "esquerda") {
        modoManual = true;
        girarEsquerda();
      } else if (cmd == "direita") {
        modoManual = true;
        girarDireita();
      } else if (cmd == "parar") {
        modoManual = true;
        parar();
      } else if (cmd == "automatico") {
        modoManual = false;
      }
    }
    Serial.println(modoManual ? "Modo manual do B1-M1 ativado." : "Modo autom√°tico do B1-M1 ativado.");
  }
  ```
  A fun√ß√£o `void onWsEvent()` foi adicionada ao c√≥digo.

  Essa fun√ß√£o √© um manipulador de eventos do protocolo WebSocket. √â ela quem define o que a ESP32 deve fazer quando um evento ocorre na conex√£o WebSocket. No caso do B1-M1, ela est√° tratando os comandos enviados ao rob√¥ B1-M1 por controle remoto via WebSocket.

  A fun√ß√£o tem a seguinte assinatura:
  * `server`: ponteiro para o servidor WebSocket;
  * `client`: ponteiro para o cliente que enviou a mensagem;
  * `type`: tipo do evento (conex√£o, desconex√£o, erro ou dados recebidos);
  * `arg`: argumento adicional (usado em eventos espec√≠ficos);
  * `data`: ponteiro para os dados recebidos (mensagem);
  * `len`: tamanho da mensagem.

  A linha `if (type == WS_EVT_DATA)` descreve bem o funcionamento do protocolo WebSocket com TCP ass√≠ncrono: a√ß√µes somente s√£o tomadas em caso de eventos (WS_EVT_DATA) espec√≠ficos.

  As linhas `String cmd  String((char*)data).substring(0, len);` e `cmd.trim();` convertem os bytes recebidos em `data` para o tipo `String`. `.trim()` remove os espa√ßos em branco no come√ßo e no final da mensagem.

  ```ino
  const char paginaHTML[] PROGMEM = R"rawliteral(
    <!DOCTYPE html>
        <html>
          <head>
            <meta charset = "utf-8">
            <title>B1-M1</title>
            <style>
              body { text-align: center; background-color: #222; color: white; font-family: sans-serif; }
              button { width: 100px; height: 50px; margin: 5px; font-size: 16px; }
              img { width: 90%; max-width: 480px; border: 2px solid #444; margin-top: 20px; }
            </style>
          </head>
          <body>
            <h2>Stream da ESP32-CAM</h2>
            <img id="cam" src="{{URL_ESP32_CAM}}">
            <h2>Comandos para o B1-M1</h2>
            <div>
              <button onclick="enviar('frente')">Frente</button><br>
              <button onclick="enviar('esquerda')">Esquerda</button>
              <button onclick="enviar('parar')">Parar</button>
              <button onclick="enviar('direita')">Direita</button><br>
              <button onclick="enviar('tras')">Tr√°s</button><br>
              <button onclick="enviar('automatico')">Modo autom√°tico</button>
            </div>
            <script>
              const ws = new WebSocket("ws://" + location.host + "/ws");
              function enviar(cmd){ ws.send(cmd); }
            </script>
          </body>
        </html>
  )rawliteral";
  ```
  A p√°gina HTML teve sua estrutura armazenada desta vez numa vari√°vel pr√≥pria na linha `const char paginaHTML[] PROGMEM`.

  `const char paginaHTML[]` define uma array constante de caracteres: uma String. Como `[]` est√° vazio, o compilador calcula o tamanho automaticamente.

  Por exemplo, `const char texto[] = "ABC";` √© uma array de 4 elementos: `A`, `B`, `C` e `\0`, que √© o terminador nulo da array.

  `PROGMEM` √© uma diretiva que instrui ao compilador que ele deve armazenar a vari√°vel na mem√≥ria flash ao inv√©s da mem√≥ria RAM. Essa diretiva √© muito √∫til para poupar espa√ßo da mem√≥ria RAM ao lidar com vari√°veis muito grandes como √© o caso da `paginaHTML`.

  ```ino
  void setup() {
    // Rede Wi-Fi
    Serial.begin(115200);
    WiFi.begin(SSID_REDE_WIFI, SENHA_REDE_WIFI);
    Serial.print("Conectando o B1-M1 √† rede Wi-Fi ");
    Serial.print(SSID_REDE_WIFI);
    while (WiFi.status() != WL_CONNECTED) {
      delay(500);
      Serial.print(".");
    }
    Serial.println("\nConex√£o estabelecida!");
    Serial.print("IP da ESP32: ");
    Serial.println(WiFi.localIP());
    // WebSocket
    ws.onEvent(onWsEvent);
    server.addHandler(&ws);
    // P√°gina principal
    server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
      String html = FPSTR(paginaHTML);
      html.replace("{{URL_ESP32_CAM}}", URL_STREAM_CAMERA);
      request->send(200, "text/html", html);
    });
    server.begin();
    Serial.println("Servidor WebSocket do B1-M1 iniciado!");
  ```
  Dentro da fun√ß√£o `void setup()` houve o acr√©scimo da l√≥gica de eventos do WebSocket.

  No bloco do `server.on()` h√° uma l√≥gica para substituir a ocorr√™ncia de `{{URL_ESP32_CAM}}` na array `paginaHTML` por `URL_STREAM_CAMERA`.

  Na linha `request->send(200, "text/html", html);` h√° o uso do operador `->`, que √© utilizado quando temos um ponteiro. Por exemplo,

  ```cpp
  class Cachorro {
    public:
      void latir() { Serial.println("Au au!"); }
  };

  Cachorro bernadete;       // Esse objeto √© minha cadela, que √© um cachorro
  Cachorro* b = &bernadete; // Ponteiro para o objeto

  bernadete.latir();    // Acesso direto que faz a Bernadete latir
  b->latir();           // Acesso via ponteiro que faz a Bernadete latir. √â equivalente a (*b).latir()
  ```

  No caso dessa linha, `request` √© um ponteiro para um objeto `AsyncWebServerRequest`. `->send()` chama o m√©todo `send()` desse objeto. Esse m√©todo chama a resposta HTTP padr√£o conforme j√° vimos no c√≥digo anterior.

</details>

---

### 20/10/2025

Nesta vers√£o foram adicionadas fun√ß√µes e trechos de c√≥digo em fun√ß√µes j√° existentes para implementar o funcionamento da telemetria do B1-M1 atrav√©s da p√°gina HTML do WebServer ass√≠ncrono WebSocket.

üíæ [C√≥digo vers√£o 10](https://gist.github.com/parodrigues-ipynb/958ebaa8788f99ceea95b4e497a6b2e0)

üé• [V√≠deo B1-M1 rodando com a vers√£o 10]()

<details>
  <summary>üìù Coment√°rios sobre o c√≥digo vers√£o 10 [clique para expandir]</summary>

  ```ino
  // LM393 - Sensor de velocidade encoder
  #define SENSOR_VELOCIDADE_MOTOR_A 34
  #define SENSOR_VELOCIDADE_MOTOR_B 35
  volatile unsigned long pulsosMotorA = 0;
  unsigned long pulsosA = 0;                // Clone de armazenamento
  volatile unsigned long pulsosMotorB = 0;
  unsigned long pulsosB = 0;                // Clone de armazenamento
  float distancia = 0;
  ```
  As vari√°veis `pulsosA`, `pulsosB` e `distancia` passaram a ter escopo global para que seu uso possa ser compartilhado com a telemetria. Antes essas vari√°veis estavam dentro do `void loop()`, no seguinte trecho:

  ```ino
  distancia = medirDistancia(); // [cm]

  // LM393 - Sensor de velocidade encoder
  noInterrupts();
  pulsosA = pulsosMotorA;
  pulsosB = pulsosMotorB;
  pulsosMotorA = 0;
  pulsosMotorB = 0;
  interrupts();
  ```

  ```ino
  const char paginaHTML[] PROGMEM = R"rawliteral(
    <!DOCTYPE html>
    <html>
  
    <head>
        <meta charset="utf-8">
        <title>B1-M1</title>
        <style>
            body {
                text-align: center;
                background-color: #222;
                color: white;
                font-family: sans-serif;
            }
  
            button {
                width: 100px;
                height: 50px;
                margin: 5px;
                font-size: 16px;
            }
  
            .painel {
                display: flex;
                justify-content: center;
                align-items: flex-start;
                gap: 20px;
                margin-top: 20px;
            }
  
            .painel img {
                width: 480px;
                max-width: 90%;
                border: 2px solid #444;
            }
  
            .coluna-lateral {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }
  
            .telemetria {
                text-align: left;
                background-color: #333;
                border: 1px solid #444;
                padding: 15px;
                width: 250px;
                border-radius: 8px;
            }
  
            @media (max-width: 700px) {
                .painel {
                    flex-direction: column;
                    align-items: center;
                }
  
                .telemetria {
                    width: 90%;
                }
            }
        </style>
    </head>
  
    <body>
        <h2>Streaming do B1-M1</h2>
  
        <div class="painel">
            <!-- Imagem √† esquerda -->
            <img id="cam" src="{{URL_ESP32_CAM}}">
  
            <!-- Lateral direita com telemetria e bot√µes -->
            <div class="coluna-lateral">
                <div class="telemetria" id="info">Aguardando dados de telemetria...</div>
                <div>
                    <h3>Comandos</h3>
                    <button onclick="enviar('frente')">Frente</button><br>
                    <button onclick="enviar('esquerda')">Esquerda</button>
                    <button onclick="enviar('parar')">Parar</button>
                    <button onclick="enviar('direita')">Direita</button><br>
                    <button onclick="enviar('tras')">Tr√°s</button><br>
                    <button onclick="enviar('automatico')">Modo autom√°tico</button>
                </div>
            </div>
        </div>
  
        <script>
            const ws = new WebSocket("ws://" + location.host + "/ws");
            function enviar(cmd) { ws.send(cmd); }
            ws.onmessage = (event) => {
                const d = JSON.parse(event.data);
                document.getElementById("info").innerHTML =
                    `Dist√¢ncia: ${d.distancia} cm<br>` +
                    `Pulsos motor A: ${d.pulsosA} | Pulsos motor B: ${d.pulsosB}<br>` +
                    `Modo atual: ${d.modo}`;
            };
        </script>
    </body>
  
    </html>
  )rawliteral";
  ```
  O layout da p√°gina HTML do B1-M1 teve modifica√ß√µes para que a exibi√ß√£o do streaming, da telemetria e dos comandos de movimento fique contida numa tela de exibi√ß√£o de navegador *desktop*.

  ```ino
  // Telemetria
  void enviarTelemetria() {
    if (ws.count() == 0) return;
  
    String dados = "{";
    dados += "\"distancia\":" + String(distancia, 1) + ",";
    dados += "\"pulsosA\":" + String(pulsosA) + ",";
    dados += "\"pulsosB\":" + String(pulsosB) + ",";
    dados += "\"modo\":\"" + String(modoManual ? "manual" : "automatico") + "\"";
    dados += "}";
  
    ws.textAll(dados);
  }
  ```
  A fun√ß√£o `void enviarTelemetria()` foi criada para comunicar atrav√©s do protocolo WebSocket os dados da telemetria para exibi√ß√£o na p√°gina HTML.

  A vari√°vel `String dados` cont√©m uma concatena√ß√£o dos dados. Embora tenha um resultado mais leg√≠vel para os autores, n√£o utilizou-se *raw string literals* (`R"rawliteral(...)rawliteral`) e *placeholders* (`{{...}}`) e `String.replace()`. O motivo foi por efici√™ncia.

  O m√©todo `String.replace()` cria v√°rias c√≥pias intermedi√°rias, o que pode consumir mais RAM e fragmentar a *heap memory* (*mem√≥ria din√¢mica*) no ESP32 se for chamado com frequ√™ncia. *Heap memory* √© uma regi√£o da RAM usada para aloca√ß√µes em tempo de execu√ß√£o - ou seja, um espa√ßo para dados cujo tamanho s√≥ √© conhecido enquanto o programa est√° rodando.

  Como a fun√ß√£o `enviarTelemetria()` pode executar mais de uma ou duas vezes por segundo, optou-se pelo m√©todo da concatena√ß√£o de `string` ao inv√©s de correr o risco de ter muitas aloca√ß√µes extras.

  O m√©todo `.textAll()` est√° na biblioteca `<ESPAsyncWebServer.h>`. Ele envia uma mensagem de texto (`string`) para todos os clientes WebSocket conectados ao servidor naquele momento. O envio √© atrav√©s de uma mensagem JSON.

  ```ino
  void loop() {
    unsigned long agora = millis(); // [ms]
  
    // Verifica√ß√£o do movimento para tr√°s
    if (movendoTras) {
      if (agora - tempoInicioTras >= duracaoTras) {
        girarEsquerda();
        movendoTras = false;
        movendoGiro = true;
        tempoInicioGiro = agora;
      }
      yield();
      return;
    }
  
    // Verifica√ß√£o do movimento de giro
    if (movendoGiro) {
      if (agora - tempoInicioGiro >= duracaoGiro) { parar(); movendoGiro = false; }
      yield();
      return;
    }
  
    if (modoManual) {
      yield();
      return;
    }
  
    if (agora - ultimoMillis >= intervaloLeituras) {
      ultimoMillis = agora;
      
      distancia = medirDistancia(); // [cm]
  
      // LM393 - Sensor de velocidade encoder
      noInterrupts();
      pulsosA = pulsosMotorA;
      pulsosB = pulsosMotorB;
      pulsosMotorA = 0;
      pulsosMotorB = 0;
      interrupts();
  
      enviarTelemetria();
      ws.cleanupClients();
  
      if (pulsosA > 5 && pulsosB > 5) {
        if (distancia > DISTANCIA_MINIMA_CM || distancia == -1) {
          moverFrente();
        } else {
          girarDireita();
        }
      } else {
        moverTras();
        movendoTras = true;
        tempoInicioTras = agora;
      }
    }
    yield();
  }
  ```
  A fun√ß√£o `enviarTelemetria()` foi adicionada ao `void loop()`. O m√©todo `cleanupClients()` teve sua posi√ß√£o transferida para logo ap√≥s a `enviarTelemetria()`.

</details>

---

### 26/10/2025

Nesta vers√£o foi instalado, calibrado e integrado um sensor LSM303DHLC GY511 para a adi√ß√£o de uma b√∫ssola digital ao B1-M1.

Tamb√©m foi adotada a arquitetura de transmiss√£o de dados atrav√©s do protocolo MQTT.

üíæ [C√≥digo vers√£o 11](https://gist.github.com/parodrigues-ipynb/699cc992c6e68aecfd2559a6be93e43e)

üé• N√£o houve necessidade de v√≠deo nessa vers√£o

<details>
  <summary>üìù Coment√°rios sobre o c√≥digo vers√£o 11 [clique para expandir]</summary>

  Foi instalada a biblioteca `LSM303` da Pololu no ArduinoIDE.

  Foi utilizado [este script](https://gist.github.com/parodrigues-ipynb/99d4b30a8cf4a63b18cbad1b848596ad) para coleta dos dados crus do LSM303. A seguir seguem coment√°rios sobre este script e seu funcionamento.

  ```ino
  #include <Wire.h>
  #include <LSM303.h>
  LSM303 bussola;
  ```
  `#include <Wire.h>` habilita a comunica√ß√£o I¬≤C, que √© o protocolo de comunica√ß√£o serial utilizado pelo LSM303.

  `LSM303 bussola;` cria um objeto que representa o m√≥dulo f√≠sico do LSM303.

  ```ino
  Serial.begin(115200);
  Wire.begin(21, 22); // (SDA, SCL)
  bussola.init();
  bussola.enableDefault();
  delay(200);
  Serial.println("mx,my,mz,ax,ay,az"); // cabe√ßalho CSV
  ```
  `Wire.begin(21,22);` informa os pinos da ESP32 para SDA (*Serial Data*) e SCL (*Serial Clock*).

  O m√©todo `.init()` inicializa a comunica√ß√£o com os sensores (acelero e magnet√¥metro). `.enableDefault()` aplica as configura√ß√µes padr√£o de ganho e sensibilidade.

  `delay(200)` d√° tempo para os sensores estabilizarem ap√≥s ligados.

  O `.println()` √© utilizado para coletar os dados para posterior envio a um documento `.csv`.

  ```ino
  bussola.read();
  Serial.print(bussola.m.x); Serial.print(",");
  Serial.print(bussola.m.y); Serial.print(",");
  Serial.print(bussola.m.z); Serial.print(",");
  Serial.print(bussola.a.x); Serial.print(",");
  Serial.print(bussola.a.y); Serial.print(",");
  Serial.println(bussola.a.z);
  delay(40); // ~25 Hz
  ```
  O m√©todo `.read()` faz a leitura dos dois sensores (acelero e magnet√¥metro). O valor em cada eixo (`x`, `y` e `z`) √© enviado pela comunica√ß√£o serial I¬≤C, separados por v√≠rgula, conforme padr√£o do `.csv`.

  O `delay(40)` √© utilizado para gerar 25 amostras por segundo ($\frac{1000 ms}{40 ms} = 25 Hz$).

  üé• [V√≠deo da coleta de dados crus dos sensores acelero e magnet√¥metro](https://imgur.com/a/g4aFAeq)

  Para armazenar os dados, foi instalado o [software PuTTY](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html), que foi configurado conforme a imagem abaixo. Foi necess√°rio executar o PuTTY como administrador para ter acesso √† comunica√ß√£o serial da porta `COM10`. O path do arquivo escolhido foi `C:\Users\Usuario\Desktop\mag_data.csv`.

  ![Configura√ß√£o PuTTY](https://i.imgur.com/iNb3KOO.jpeg)

  √â importante notar que √†s vezes o PuTTY gera um cabe√ßalho com informa√ß√µes al√©m dos dados coletados. Para corrigir isso, basta abrir o arquivo e remover as primeiras linhas at√© que ele fique semelhante √† imagem abaixo.

  ![.csv do PuTTY corrigido](https://i.imgur.com/px6s7yR.jpeg)

  [Este script Python](https://gist.github.com/parodrigues-ipynb/0648d8b6c1c98801b7eef37fe56ecd2d) foi desenvolvido para calibra√ß√£o dos dados coletados pelos sensores magneto e aceler√¥metro. O script tamb√©m imprime gr√°ficos para compara√ß√£o da leitura de dados dos sensores antes e depois da calibra√ß√£o.

 üé• [Excelente v√≠deo que fala sobre a calibra√ß√£o dos dados dos sensores acelero e magnet√¥metro](https://www.youtube.com/watch?v=MinV5V1ioWg)

 üé• [√ìtimo v√≠deo para visualizar a causa das distor√ß√µes hard-iron e soft-iron](https://www.youtube.com/watch?v=cGI8mrIanpk&t=196s)

  Os dois arquivos foram colocados no desktop, conforme a imagem abaixo.

  ![Arquivos](https://i.imgur.com/GnDEfEX.jpeg)

  O Windows PowerShell foi aberto no Desktop e o script Python foi executado com a linha de comando `python calib_lsm303.py mag_data.csv`, conforme a caixa amarela na imagem abaixo. O script retornou os valores de offset e scale para calibra√ß√£o dos sensores, assim como criou uma pasta contendo as imagens dos gr√°ficos dos dados antes e depois da calibra√ß√£o, conforme a caixa laranja na mesma imagem.

  ![Execu√ß√£o do script Python](https://i.imgur.com/pGMKVM1.jpeg)

  A imagem abaixo apresenta os gr√°ficos obtidos com a an√°lise dos dados do .csv.

  ![Gr√°ficos](https://i.imgur.com/TcS6qUt.jpeg)

  üé• [V√≠deo comparando os gr√°ficos tridimensionalmente](https://imgur.com/a/l8q1bQo)

  Ap√≥s a calibra√ß√£o, observou-se que a vers√£o calibrada estava elipsoidal nos planos x, y e x, z na visualiza√ß√£o 3D. Isso se deve √† escala distorcida na visualiza√ß√£o.

</details>

---

### 26/10/2025

Nesta vers√£o foi implementado o m√≥dulo LSM303DHLC GY511 para servir de b√∫ssola digital no B1-M1.

üíæ [C√≥digo vers√£o 12](https://gist.github.com/parodrigues-ipynb/321e96d45b61859578bc1fb003bc0cd2)

üé• N√£o houve necessidade de v√≠deo nessa vers√£o

<details>
  <summary>üìù Coment√°rios sobre o c√≥digo vers√£o 10 [clique para expandir]</summary>

  W.I.P.

</details>


[^1]: O [datasheet da Espressif](https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf) apresenta diferentes consumos para situa√ß√µes de transmiss√£o ou recep√ß√£o de Wi-Fi/Bluetooth, light-sleep, deep-sleep... Esses valores podem ser consultados nas tabelas *Table 4-2. Power Consumption by Power Modes* na **p√°gina 30** e *Table 5-4. Current Consumption Depending on RF Modes* na **p√°gina 53**. Em fun√ß√£o dos diversos poss√≠veis valores de corrente para cada modo de funcionamento, adotou-se o pior caso (maior consumo de ~250mA com transmiss√£o Wi-Fi 802.11b ativa).

[^2]: O [datasheet consultado](https://www.handsontec.com/dataspecs/module/ESP32-CAM.pdf) apresenta valores em torno de 200mA para c√¢mera ligada/flash desligado e 300mA para c√¢mera ligada/flash ligado. Os valores podem aumentar em caso de streaming por Wi-Fi. Adotou-se o valor m√©dio.

[^3]: [O valor de corrente de 200mA por cada motor √© para situa√ß√µes sem carga](https://www.usinainfo.com.br/motor-dc/motor-dc-3-6v-200rpm-com-caixa-de-reducao-e-eixo-duplo-481--3161.html), nas quais os motores est√£o girando sem resist√™ncias mec√¢nicas. Se houver atrito, inclina√ß√£o, a pr√≥pria massa do rob√¥..., o valor de corrente pode subir consideravelmente, chegando a valores de at√© 1,5A por motor. Como n√£o pode-se encontrar um datasheet para o motor espec√≠fico utilizado, confiou-se nos valores apresentados pelo vendedor.
