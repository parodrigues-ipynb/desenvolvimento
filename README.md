# Cuidado de idosos

Este documento tem por objetivo registrar as etapas de desenvolvimento das diversas partes (rob√¥, sensores, alarmes...) que integram o projeto de cuidado de idosos sendo desenvolvido por um grupo de alunos na disciplina **Desenvolvimento de Aplica√ß√µes para Automa√ß√£o** ministrada pelo professor Alexandre St√ºrmer Wolf na Univates.

O grupo √© integrado por:
* Anderson da Silva Quadros;
* Jonathan Tabaldi Bassani;
* Marcelo Teichenbach;
* Pedro Augusto Rodrigues;
* Samuel Dornelles

Cada membro do grupo envolveu-se em diferentes partes do projeto.

![B1-M1](https://media1.giphy.com/media/v1.Y2lkPTZjMDliOTUyYWtraTV2dTdxNW42OGphMnJvZnplNmpqM2wzbmhwb2UxcnhpdDFkbCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/3o7abB06u9bNzA8lu8/giphy.gif)

## B1-M1 - Rob√¥ de monitoramento
Membros envolvidos:
* Anderson da Silva Quadros;
* Pedro Augusto Rodrigues

O B1-M1 √© um rob√¥ de monitoramento.

---

### Rela√ß√£o de componentes utilizados

1x [Placa de desenvolvimento ESP32S-NodeMCU 38 pinos](https://www.usinainfo.com.br/esp32/esp32s-nodemcu-iot-com-wifi-e-bluetooth-38-pinos-com-usb-c-e-cp2102-8796.html)

1x [Placa de desenvolvimento ESP32-CAM-CH340 com c√¢mera OV2640](https://www.usinainfo.com.br/esp32/esp32-cam-ch340-ov2640-iot-com-programador-integrado-8758.html)

3x [Bateria de l√≠tio 18650 3.7V recarreg√°vel button-top](https://www.usinainfo.com.br/baterias/bateria-18650-litio-recarregavel-37v-3800mah-button-top-kit-com-2-unidades-8170.html)

1x [Suporte para 3 baterias 18650](https://www.usinainfo.com.br/suporte-para-pilhas/suporte-para-3-baterias-18650-smt-9059.html)

1x [Placa de prote√ß√£o para bateria (BMS - Battery Management System) 18650-3S-20A](https://www.usinainfo.com.br/controladores-de-carga/placa-de-protecao-para-bateria-18650-3s-20a-12v-hx-3s-fl20-7070.html)

1x [Regulador de tens√£o XL4015 DC/DC step down 8-36V ‚Üí 1,25-32V 0,2-3A](https://www.usinainfo.com.br/regulador-de-tensao/regulador-de-tensao-e-corrente-ajustavel-xl4015-dc-step-down-saida-125-a-32vdc-02-a-3a-5880.html)

1x [Regulador de tens√£o LM2596DC DC/DC step down 3,2-40V ‚Üí 1,5-35V 1,2A](https://www.usinainfo.com.br/regulador-de-tensao/regulador-de-tensao-ajustavel-lm2596-dc-step-down-saida-15v-a-35vdc-12a-2552.html)

1X [Sensor de dist√¢ncia ultrass√¥nico HC-SR04](https://www.usinainfo.com.br/sensor-ultrassonico/sensor-ultrassonico-de-distancia-hc-sr04-2295.html)

1x [Driver motor DC ponte H TB6612FNG](https://www.usinainfo.com.br/driver-para-motor/driver-tb6612fng-duplo-ponte-h-de-motor-dc-ou-passo-4697.html)

2x [Motor DC 3~6V 200RPM com caixa de redu√ß√£o 48:1](https://www.usinainfo.com.br/motor-dc/motor-dc-3-6v-200rpm-com-caixa-de-reducao-e-eixo-duplo-481--3161.html)

2x [Sensor de velocidade LM393](https://www.usinainfo.com.br/sensor-de-velocidade/sensor-de-velocidade-para-arduino-sensor-de-contagem-chave-optica-para-encoder-5mm-4486.html)

E uma infinidade de terminais, parafusos, porcas, brocas, fixadores, cabos, espa√ßadores... utilizados para montar o rob√¥ em uma estrutura de MDF.

---

### Memorial de c√°lculo de dimensionamento
O grupo pretende alcan√ßar os seguintes objetivos para o rob√¥ B1-M1:
1. mover-se seguindo uma rotina pr√©-determinada em um ambiente residencial plano e permitir controle remoto;
2. registrar valores obtidos pelo sensoriamento ultrass√¥nico e visual (fotografias) e permitir o stream (v√≠deo) durante o acesso remoto;
3. comunicar-se com o Gemini atrav√©s da API fornecida pelo Google a fim de obter instru√ß√µes para movimento aut√¥nomo.

Para alcan√ßar os objetivos acima listados foi determinada a necessidade dos componentes listados na se√ß√£o [Rela√ß√£o de componentes utilizados](#relacao-de-componentes-utilizados).

Como a alimenta√ß√£o el√©trica √© a espinha dorsal de todo projeto de eletr√¥nica embarcada, o primeiro passo dado pelo grupo foi estimar o consumo de corrente dos componentes utilizados para atingir os objetivos.

#### Consumo de corrente

| Componente                        | Quantidade  | Consumo total | 
|-----------------------------------|:-----------:|:-------------:|
| ESP32S-NodeMCU                    | 1           | ~250mA[^1]    |
| ESP32-CAM                         | 1           | ~250mA[^2]    |
| Sensor ultrass√¥nico HC-SR04       | 1           | ~15mA         |
| Driver motor TB6612FNG            | 1           | ~1,5mA        |
| Motor DC 3-6V 200RPM              | 2           | ~400mA[^3]    |
| Sensor de velocidade LM393        | 2           | ~20mA         |
| **Total**                         | **8**       | **~936,5mA**  |

Para fins de c√°lculo, arredondar-se-√° o consumo total para 1A (1000mA).

#### Autonomia

![18650](https://i.imgur.com/KVCxV1z.jpeg)

As baterias de l√≠tio 18650 t√™m gravado nos seus inv√≥lucros a capacidade de carga el√©trica de **3800mAh**. Por√©m, [√© interessante notar que o vendedor fez testes e alegou a capacidade de apenas 1500mAh](https://www.usinainfo.com.br/baterias/bateria-18650-litio-recarregavel-37v-3800mah-flat-top-8760.html). Portanto, para fins de c√°lculo neste trabalho, adotar-se-√° o valor de **1500mAh**.

Fazendo um c√°lculo simples de autonomia,

$Autonomia = \frac{Capacidade \ de \ carga \ el√©trica}{Consumo \ de \ corrente \ el√©trica} = \frac{1500mAh}{1000mA} ‚âà 1,5h$

Logo, o grupo espera que o B1-M1 tenha uma autonomia de aproximadamente **1 hora e 30 minutos** funcionando com as premissas de consumo feitas na tabela **Consumo de corrente**.

#### Se√ß√£o dos cabos utilizados

Como cabos de bitola 1mm¬≤ suportam correntes cont√≠nuas de at√© 10A, adotou-se o seu uso nas conex√µes do pack de baterias 18650 com a BMS e da BMS com os reguladores de tens√£o.

Nas demais conex√µes utilizou-se cabos de 0,75mm¬≤, que suportam correntes cont√≠nuas de at√© 8A.

---

### Esquem√°tico

Uma imagem do esquem√°tico pode ser vista [aqui](https://i.imgur.com/tPJJAKS.png)

Algumas notas sobre decis√µes feitas s√£o colocadas a seguir.

#### Capacitores de desacoplamento de 100nF nos terminais dos motores A e B

![Motores escovados](https://i.imgur.com/TV1qZob.jpeg)

Motores produzem ru√≠do.

Nos motores DC utilizados neste projeto, uma das fontes de ru√≠do poss√≠veis √© devido √† comuta√ß√£o entre as escovas de carbono e o anel coletor laminado (o comutador) do induzido.

[GIF mostrando os arcos voltaicos](https://i.imgur.com/fCO2iG0.gif)

Quando as escovas e as l√¢minas do anel coletor comutam ocorrem arcos voltaicos (*comutar = ligar ou desligar, interromper e religar uma liga√ß√£o el√©trica*). Esses arcos ocorrem pois uma vez energizadas as bobinas do enrolamento do induzido se comportam como indutores.

A equa√ß√£o da tens√£o para indutores √© $v = L \frac{di}{dt}$. Ou seja, a tens√£o √© proporcional √† taxa de varia√ß√£o da corrente. Quando a comuta√ß√£o ocorre, a taxa de varia√ß√£o da corrente √© abrupta e intensa (indo de 100% para 0% em um intervalo de tempo muito pequeno). Essa grande taxa de varia√ß√£o provoca um pico de tens√£o nas bobinas e, por consequ√™ncia, os arcos voltaicos entre as escovas e as l√¢minas do anel coletor. Os picos de tens√£o no funcionamento de um motor DC podem ser vistos na imagem abaixo.

![Ru√≠do](https://i.imgur.com/wnImMP7.jpeg)

Esse ru√≠do pode afetar o funcionamento de outras partes do circuito.

---

### Desenvolvimento do c√≥digo

Tanto os alunos Anderson quanto Pedro nunca fizeram antes um projeto de rob√≥tica.

Para fins did√°ticos e de cria√ß√£o de um memorial de aprendizado, o grupo decidiu documentar o progresso do desenvolvimento do c√≥digo utilizado no B1-M1.

A documenta√ß√£o √© apresentada abaixo em ordem cronol√≥gica. Cada inser√ß√£o conta com notas pessoais de aprendizado do grupo.

---

#### 13/10/2025

üíæ [C√≥digo vers√£o 1](https://gist.github.com/parodrigues-ipynb/be9dc512e9a064356e3e1a73c458425b)

üé• [V√≠deo B1-M1 rodando com a vers√£o 1](https://imgur.com/a/WtTMg6K)

**Coment√°rios sobre o c√≥digo**

```ino
// Linha 2
#define PWMA 4
```
`#define` √© uma diretiva de pr√©-processador da linguagem C/C++ que cria uma constante simb√≥lica. O compilador substitui todas as ocorr√™ncias do nome pelo valor definido antes de compilar. Por exemplo, `#define PWMA 4` substitui `PWMA` por `4` no momento anterior √† compila√ß√£o. O uso de `#define` √© √∫til para mapear pinos e definir valores fixos/limites (dist√¢ncias, velocidades...) que permanecer√£o constantes ao longo do c√≥digo, tornando as informa√ß√µes mais claras e f√°ceis de alterar.

```ino
// Linha 10
uint8_t pwmA = 94;
```
A vari√°vel `pwmA` ir√° armazenar os valor de duty cycle para o sinal PWM enviado ao motor A.

PWM significa *Pulse Width Modulation*, ou *Modula√ß√£o de Largura de Pulso*. *Duty cycle*, ou *ciclo de trabalho*, representa a raz√£o entre a **largura de pulso** ($t_{ON}$), que √© o tempo em que o sinal permanece em n√≠vel HIGH, e o **per√≠odo total do sinal** ($T$), conforme a express√£o:

$$
Duty \ cycle = \frac{t_{ON}}{T} √ó 100 \\%
$$

Por exemplo, se o per√≠odo $T$ fosse 100ms, um *duty cycle* de 25% teria uma largura de pulso $t_{ON}$ de 25ms.

![Sinal PWM](https://i.imgur.com/OkiNbwV.jpeg)

A imagem acima mostra diferentes sinais de tens√£o PWM. As linhas verticais laranjas s√£o as marca√ß√µes de tempo. Portanto, todos os sinais compartilham o mesmo per√≠odo $T$.

Na imagem os sinais de tens√£o PWM t√™m *duty cycles* distintos: 0%, 25%, 50%, 75% e 100%.

√â uma pr√°tica comum utilizar vari√°veis num√©ricas para representar o *duty cycle* em c√≥digo. Por exemplo, seria teoricamente poss√≠vel criar uma vari√°vel `int pwmA = 0` para representar um *duty cycle* de 0%. Caso fosse desej√°vel alterar o duty cycle para 1%, poderia-se simplesmente alterar o valor da vari√°vel para `pwma = 1`, ou 2% ‚Üí `pwma = 2`, e assim por diante.

O tipo de vari√°vel `int` √© usado para armazenar n√∫meros inteiros (-2, -1, 0, 1, 2, 3...). Na ESP32, o `int` ocupa **4 bytes** (32 bits) - o que faz sentido, j√° que o microcontrolador √© baseado em arquitetura 32 bits. Os valores poss√≠veis para vari√°veis do tipo `int` v√£o de -2,147,483,648 at√© 2,147,483,647. √â poss√≠vel utlizar `unsigned int` para trabalhar-se com o intervalo de 0 at√© 4,294,967,295 (aproximadamente 4 bilh√µes).

Portanto, no caso da linha 10, poder√≠amos teoricamente utilizar a vari√°vel `unsigned int pwmA` para mapear o *duty cycle*. Se desej√°ssemos utilizar todo o potencial de armazenamento do tipo `unsigned int`, como queremos mapear valores de 0% at√© 100% num intervalo de 0 at√© 4,294,967,295, far√≠amos $\frac{100 - 0}{4,294,967,295 - 0} ‚âà 0,00000002328$.

Assim, ter√≠amos a seguinte resolu√ß√£o:
* `pwmA = 0             // ‚Üí 0%`
* `pwmA = 1             // ‚Üí ‚âà 0,00000002328%`
* `pwmA = 2             // ‚Üí ‚âà 0,00000004657%`
* ...
* `pwmA = 4294967294 // ‚Üí ‚âà 99,9999999767%`
* `pwmA = 4294967295 // ‚Üí 100%`

Agora imaginemos programadores tendo de cotidianamente utilizar essa resolu√ß√£o em seus c√≥digos. Seria um pesadelo ter de lembrar o valor 4294967295, e muito dif√≠cil lembrar os valores que mapeam para aproximadamente 25%, 50%, 75%...
  
Portanto, no caso de sinais PWM, √© comum utilizar-se tipos de vari√°veis de apenas **1 byte** (8 bits), que na base bin√°ria ($2^n$) correspondem a 256 valores poss√≠veis ($2^8 = 256$). Como $\frac{100-0}{255-0} ‚âà 0,39$, ter√≠amos a seguinte resolu√ß√£o:
* `pwmA = 0             // ‚Üí 0%`
* `pwmA = 1             // ‚Üí ‚âà 0,39%`
* `pwmA = 2             // ‚Üí ‚âà 0,78%`
* ...
* `pwmA = 254 // ‚Üí ‚âà 99,61%`
* `pwmA = 255 // ‚Üí 100%`

Fica evidente que 1 byte j√° traz uma resolu√ß√£o adequada para se programar e ainda possibilita inferir algumas porcentagens intuitivamente: como 100% ‚Üí 255, ent√£o 50% deve ser algo em torno de 127, 25% deve ser algo em torno de 64... e assim por diante.

`uint8_t` significa *unsigned integer of length 8 bits*, ou *n√∫mero inteiro sem sinal de comprimento de 8 bits*. √â muito comum encontrar softwares e hardwares que utilizam sinais PWM mapeados por vari√°veis de 8 bits. Entretanto, √© sempre bom ficar atento √†s conven√ß√µes adotadas em cada projeto pois pode haver casos em que uma maior resolu√ß√£o √© necess√°ria a fim de alcan√ßar maior precis√£o.

 


[^1]: O [datasheet da Espressif](https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf) apresenta diferentes consumos para situa√ß√µes de transmiss√£o ou recep√ß√£o de Wi-Fi/Bluetooth, light-sleep, deep-sleep... Esses valores podem ser consultados nas tabelas *Table 4-2. Power Consumption by Power Modes* na **p√°gina 30** e *Table 5-4. Current Consumption Depending on RF Modes* na **p√°gina 53**. Em fun√ß√£o dos diversos poss√≠veis valores de corrente para cada modo de funcionamento, adotou-se o pior caso (maior consumo de ~250mA com transmiss√£o Wi-Fi 802.11b ativa).

[^2]: O [datasheet consultado](https://www.handsontec.com/dataspecs/module/ESP32-CAM.pdf) apresenta valores em torno de 200mA para c√¢mera ligada/flash desligado e 300mA para c√¢mera ligada/flash ligado. Os valores podem aumentar em caso de streaming por Wi-Fi. Adotou-se o valor m√©dio.

[^3]: [O valor de corrente de 200mA por cada motor √© para situa√ß√µes sem carga](https://www.usinainfo.com.br/motor-dc/motor-dc-3-6v-200rpm-com-caixa-de-reducao-e-eixo-duplo-481--3161.html), nas quais os motores est√£o girando sem resist√™ncias mec√¢nicas. Se houver atrito, inclina√ß√£o, a pr√≥pria massa do rob√¥..., o valor de corrente pode subir consideravelmente, chegando a valores de at√© 1,5A por motor. Como n√£o pode-se encontrar um datasheet para o motor espec√≠fico utilizado, confiou-se nos valores apresentados pelo vendedor.
